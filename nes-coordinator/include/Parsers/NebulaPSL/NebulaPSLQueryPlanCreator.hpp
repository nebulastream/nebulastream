/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#ifndef NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_
#define NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_

#include <Common/DataTypes/DataTypeFactory.hpp>
#include <Expressions/ConstantValueExpressionNode.hpp>
#include <Expressions/LogicalExpressions/EqualsExpressionNode.hpp>
#include <Expressions/LogicalExpressions/LessExpressionNode.hpp>
#include <Operators/LogicalOperators/Network/NetworkSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/FileSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/KafkaSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/MQTTSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/NullOutputSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/OPCSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/PrintSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/ZmqSinkDescriptor.hpp>
#include <Parsers/NebulaPSL/NebulaPSLOperator.hpp>
#include <Parsers/NebulaPSL/NebulaPSLPattern.hpp>
#include <Parsers/NebulaPSL/gen/NesCEPBaseListener.h>
#include <Plans/Query/QueryPlan.hpp>
#include <string>

namespace NES::Parsers {
/**
 * @brief This class creates the query plan from ANTLR AST
 * It inherits from the auto-generated ANTLR base listener to walk the AST created from the pattern string.
 * This enables the parsing of declarative patterns into NES queries.
 */
class NesCEPQueryPlanCreator : public NesCEPBaseListener {
  public:
    /** the following methods read out the AST tree and collect all mined patterns in the global pattern list
     * An example of the AST looks as follows:
     * (query (cepPattern PATTERN test := (compositeEventExpressions (
        (listEvents (eventElem (event A)) (operatorRule AND) (eventElem (event B))) ))
        FROM (inputStreams (inputStream default_logical AS A) , (inputStream default_logical_b AS B))
        WHERE (whereExp (expression (predicate (predicate (expressionAtom (eventAttribute A . (attribute currentSpeed)))) (comparisonOperator <) (predicate (expressionAtom (eventAttribute A . (attribute allowedSpeed)))))))
        WITHIN (timeConstraints [ (interval 3 (intervalType MINUTE)) ])
        INTO (sinkList (sink (sinkType Print) :: testSink))) <EOF>
     * each keyword in the AST has its two functions, enter (when X is visited) and exist (called after all children of X have been visited), contained in the parent class NesCEPBaseListener,
     * auto-generated by the ANTLR dependency (gen-folders)
     */

    /** @brief enables to enter entire pattern context, requires to early enter the window specifcaiton
      * @param context
      */
    void enterCepPattern(NesCEPParser::CepPatternContext* context) override;

    //ListEvents
    /** @brief mines pattern from the PATTERN clause
      * @param context
      */
    void enterListEvents(NesCEPParser::ListEventsContext* context) override;

    // EventElement
    /** @brief marks current (event) element as a child of the currentOperatorPointer subPattern and
      * move one step up in the AST hierarchy
      * @param context*/

    void enterEventElem(NesCEPParser::EventElemContext* context) override;

    /** @brief recieves a ListEventsContext if enterEventElem finds a left parenthesis.
     * Creates and adds a subquery containing the parenthesized part from the given query string
     * as a source to the main pattern
     * @param context
     * TODO can we use a smart instead of a raw NesCEPParser::ListEventsContext* #5165 ?
     */
    void handleParenthesizedExpression(NesCEPParser::ListEventsContext* context);

    // Event
    /**
      * @brief marks the position of the event inside of the currentElementPointer subPattern
      * @param context

    void enterEvent(NesCEPParser::EventContext* context) override;*/

    // Operators

    /**
      * @brief leaves the current operator element and changes direction to right to mine right branch for binary operators
      * @param context
      */
    void exitOperatorRule(NesCEPParser::OperatorRuleContext* context) override;

    // FROM clause
    /** @brief substitutes the input stream alias by its real name in every subPattern
      * @param context
      */
    void exitInputStream(NesCEPParser::InputStreamContext* context) override;

    // WHERE clause
    /** @brief marks that the tree walker starts parsing a WHERE clause
      * @param context
      */
    void enterWhereExp(NesCEPParser::WhereExpContext* context) override;

    /** @brief marks that the tree walker finished parsing the WHERE clause
      * @param context
      */
    void exitWhereExp(NesCEPParser::WhereExpContext* context) override;

    //INTO clause
    /**
      * @brief adds a sink operator to the sink list, calls different methods for sinkd with (File and MQTT) and without parameters
      * @param context
      */
    void enterSinkWithParameters(NesCEPParser::SinkWithParametersContext* context) override;
    void enterSinkWithoutParameters(NesCEPParser::SinkWithoutParametersContext* context) override;

    // WITHIN clause
    /** @brief
      * @param context
      */
    void enterWindowConstraints(NesCEPParser::WindowConstraintsContext*) override;

    /**
      * @brief collects all projection attributes
      * @param context
      */
    void enterOutAttribute(NesCEPParser::OutAttributeContext* context) override;

    /**
      * @brief add the appropriate iteration operator to the OperatorList
      * @param context
      */
    void enterQuantifiers(NesCEPParser::QuantifiersContext* context) override;

    /**
         * @brief extracts WHERE Expressions
         * @param context
         */
    void exitBinaryComparisonPredicate(NesCEPParser::BinaryComparisonPredicateContext* context) override;

    /**
     * @brief this method creates the query from the NesPattern
     */
    QueryPlanPtr createQueryFromPatternList() const;

    /**
     * @brief this methods add all filter to the queryPlan
     */
    QueryPlanPtr addFilters(QueryPlanPtr queryPlan) const;

    /**
     * @brief this methods parses the user-specified window information to TimeMeasures
     */
    Windowing::TimeMeasure transformWindowToTimeMeasurements(std::pair<std::string, int> timeMeasure) const;

    /**
     * @brief this methods add all projections to the queryPlan
     */
    QueryPlanPtr addProjections(QueryPlanPtr queryPlan) const;

    /**
     * @brief returns the parsed queryPlan
     */
    QueryPlanPtr getQueryPlan() const;

    /**
     * @brief: this function creates an artificial key for the binary operators AND and SEQ
     * @return the unique name of the key
     */
    std::string keyAssignment(std::string keyName) const;

    /**
     * @brief: this function adds a binary operator to the query plan
     * @param operaterName the operator name
     * @param iterator the list of nodes from the ANTLR AST Tree
     */
    QueryPlanPtr addBinaryOperatorToQueryPlan(std::string operaterName,
                                              std::map<int, NebulaPSLOperator>::const_iterator iterator,
                                              QueryPlanPtr queryPlan) const;

    /**
     * @brief: checks if one of the sources for a binary operator is already part of either the left or right queryPlan that are composed by the binary operator, i.e., already added to the final queryPlan
     * @param leftSourceName as string
     * @param rightSourceName as string
     * @return the queryPlan to compose to the final queryPlan
     */
    QueryPlanPtr checkIfSourceIsAlreadyConsumedSource(std::basic_string<char> leftSourceName,
                                                      std::basic_string<char> rightSourceName,
                                                      QueryPlanPtr queryPlan) const;
    /**
     * @brief: Parse the expression node of one side (either left or right) from the ANTLR provided context
     * @param contextValueAsString as string
     * @return the ExpressionNodePtr of the created expression node (ExpressionItem for constant values, Attribute node else)
     */
    ExpressionNodePtr getExpressionItem(std::string contextValueAsString);

    /**
     * @brief: triggers the parsing of the within clause to create the window
     * @return the WindowTypePtr
     */
    WindowTypePtr createTimeBasedWindow() const;

    /**
     * @brief: triggers the parsing of the within clause to check and transform the specified window parameters for the intervalJoin
     * @return par of required parameters
     */
    std::pair<uint64_t, TimeUnit> createIntervalWindow() const;

  private:
    // pointers to track relationship of AST elements while retrieving pattern specification
    int32_t sourceCounter = 0;
    int32_t lastSeenSourcePtr = -1;

    NebulaPSLPattern pattern;
    int32_t nodeId = 0;
    bool inWhere = false;
    std::map<std::string, QueryPlanPtr> subQueries;
    /** a map holding context for nested patterns
    std::string: virtual subquery name following the naming scheme "SubQuery_" + std::to_string(nodeId)
    QueryPlanPtr: the queryPlanPointer for the created subquery */
};

}// namespace NES::Parsers

#endif// NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_
