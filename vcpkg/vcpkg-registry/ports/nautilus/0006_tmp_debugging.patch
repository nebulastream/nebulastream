Index: nautilus/include/nautilus/Engine.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/nautilus/include/nautilus/Engine.hpp b/nautilus/include/nautilus/Engine.hpp
--- a/nautilus/include/nautilus/Engine.hpp	(revision 364c89c184430e1ccd0d9422fc73b1cc54c33ca8)
+++ b/nautilus/include/nautilus/Engine.hpp	(date 1755017963490)
@@ -65,99 +65,113 @@

 	explicit CallableFunction(std::unique_ptr<compiler::Executable>& executable)
 	    : func(executable->getInvocableMember<typename R::raw_type, FunctionArguments...>("execute")),
-	      executable(std::move(executable)) {}
+	      executable(std::move(executable)) {
+	}

-		CallableFunction(const CallableFunction& other) = delete;
-		CallableFunction(CallableFunction && other) noexcept
-		    : func(std::move(other.func)), executable(std::move(other.executable)) {
-		}
-		CallableFunction& operator=(const CallableFunction& other) = delete;
-		CallableFunction& operator=(CallableFunction&& other) noexcept {
-			if (this == &other)
-				return *this;
-			func = std::move(other.func);
-			executable = std::move(other.executable);
-			return *this;
-		}
+	CallableFunction(const CallableFunction& other) = delete;
+	CallableFunction(CallableFunction&& other) noexcept
+	    : func(std::move(other.func)), executable(std::move(other.executable)) {
+	}
+	CallableFunction& operator=(const CallableFunction& other) = delete;
+	CallableFunction& operator=(CallableFunction&& other) noexcept {
+		if (this == &other)
+			return *this;
+		func = std::move(other.func);
+		executable = std::move(other.executable);
+		return *this;
+	}

-		typename R::raw_type operator()(FunctionArguments... args) {
-			return std::visit(
-			    overloaded {[&](std::function<R(val<FunctionArguments>...)>& fn) -> typename R::raw_type {
-				                return nautilus::details::RawValueResolver<typename R::raw_type>::getRawValue(
-				                    fn(make_value(args)...));
-			                },
-			                [&](compiler::Executable::Invocable<typename R::raw_type, FunctionArguments...>& fn) ->
-			                typename R::raw_type {
-				                return fn(args...);
-			                }},
-			    func);
-		}
+	typename R::raw_type operator()(FunctionArguments... args) {
+		return std::visit(
+		    overloaded {[&](std::function<R(val<FunctionArguments>...)>& fn) -> typename R::raw_type {
+			                return nautilus::details::RawValueResolver<typename R::raw_type>::getRawValue(
+			                    fn(make_value(args)...));
+		                },
+		                [&](compiler::Executable::Invocable<typename R::raw_type, FunctionArguments...>& fn) ->
+		                typename R::raw_type {
+			                return fn(args...);
+		                }},
+		    func);
+	}

-	private:
-		std::variant<std::function<R(val<FunctionArguments>...)>,
-		             compiler::Executable::Invocable<typename R::raw_type, FunctionArguments...>>
-		    func;
-		std::unique_ptr<compiler::Executable> executable;
-	};
+private:
+	std::variant<std::function<R(val<FunctionArguments>...)>,
+	             compiler::Executable::Invocable<typename R::raw_type, FunctionArguments...>>
+	    func;
+	std::unique_ptr<compiler::Executable> executable;
+};

-	/// Specialization for void return type
-	template <typename... FunctionArguments>
-	class CallableFunction<void, FunctionArguments...> {
-	public:
-		explicit CallableFunction(std::function<void(val<FunctionArguments>...)> func)
-		    : func(func), executable(nullptr) {
-		}
+/// Specialization for void return type
+template <typename... FunctionArguments>
+class CallableFunction<void, FunctionArguments...> {
+public:
+	explicit CallableFunction(std::function<void(val<FunctionArguments>...)> func) : func(func), executable(nullptr) {
+	}

-		explicit CallableFunction(std::unique_ptr<compiler::Executable>& executable)
-		    : func(executable->getInvocableMember<void, FunctionArguments...>("execute")),
-		      executable(std::move(executable)) {
-		}
+	explicit CallableFunction(std::unique_ptr<compiler::Executable>& executable)
+	    : func(executable->getInvocableMember<void, FunctionArguments...>("execute")),
+	      executable(std::move(executable)) {
+	}

-		auto operator()(FunctionArguments... args) {
-			std::visit(overloaded {[&](std::function<void(val<FunctionArguments>...)>& fn) { fn(make_value(args)...); },
-			                       [&](compiler::Executable::Invocable<void, FunctionArguments...>& fn) {
-				                       fn(args...);
-			                       }},
-			           func);
-		}
+	CallableFunction(const CallableFunction& other) = delete;
+	CallableFunction(CallableFunction&& other) noexcept
+	    : func(std::move(other.func)), executable(std::move(other.executable)) {
+	}
+	CallableFunction& operator=(const CallableFunction& other) = delete;
+	CallableFunction& operator=(CallableFunction&& other) noexcept {
+		if (this == &other)
+			return *this;
+		func = std::move(other.func);
+		executable = std::move(other.executable);
+		return *this;
+	}
+	auto operator()(FunctionArguments... args) {
+		std::visit(overloaded {[&](std::function<void(val<FunctionArguments>...)>& fn) { fn(make_value(args)...); },
+		                       [&](compiler::Executable::Invocable<void, FunctionArguments...>& fn) {
+			                       fn(args...);
+		                       }},
+		           func);
+	}

-	private:
-		std::variant<std::function<void(val<FunctionArguments>...)>,
-		             compiler::Executable::Invocable<void, FunctionArguments...>>
-		    func;
-		std::unique_ptr<compiler::Executable> executable;
-	};
+private:
+	std::variant<std::function<void(val<FunctionArguments>...)>,
+	             compiler::Executable::Invocable<void, FunctionArguments...>>
+	    func;
+	std::unique_ptr<compiler::Executable> executable;
+};

-	/**
-	 * The Nautilus Engine maintains the execution context of one or multiple nautilus functions,
-	 * which are registered using registerFunction.
-	 * Depending on the provided options, this functions may be compiled using a compilation backend or are executed
-	 * directly. In general, the NautilusEngine mussed outlive any registered functions.
-	 */
-	class NautilusEngine {
-	public:
-		NautilusEngine(const Options& options = Options());
+/**
+ * The Nautilus Engine maintains the execution context of one or multiple nautilus functions,
+ * which are registered using registerFunction.
+ * Depending on the provided options, this functions may be compiled using a compilation backend or are executed
+ * directly. In general, the NautilusEngine mussed outlive any registered functions.
+ */
+class NautilusEngine {
+public:
+	NautilusEngine(const Options& options = Options());

-		template <typename R, is_val... FunctionArguments>
-		auto registerFunction(R (*fnptr)(val<FunctionArguments>...)) const {
-			std::function<R(val<FunctionArguments>...)> inputFunction = fnptr;
-			return registerFunction(inputFunction);
-		}
+	template <typename R, is_val... FunctionArguments>
+	auto registerFunction(R (*fnptr)(val<FunctionArguments>...)) const {
+		std::function<R(val<FunctionArguments>...)> inputFunction = fnptr;
+		return registerFunction(inputFunction);
+	}

-		template <typename R, typename... FunctionArguments>
-		auto registerFunction(std::function<R(val<FunctionArguments>...)> func) const {
+	template <typename R, typename... FunctionArguments>
+	auto registerFunction(std::function<R(val<FunctionArguments>...)> func) const {
 #ifdef ENABLE_TRACING
-			if (options.getOptionOrDefault("engine.Compilation", true)) {
-				auto wrapper = details::createFunctionWrapper(func);
-				auto executable = jit.compile(wrapper);
-				return CallableFunction<R, FunctionArguments...>(executable);
-			}
+		if (options.getOptionOrDefault("engine.Compilation", true)) {
+			auto wrapper = details::createFunctionWrapper(func);
+			auto executable = jit.compile(wrapper);
+			CallableFunction<R, FunctionArguments...> callableFunction(executable);
+			return std::move(callableFunction);
+		}
 #endif
-			return CallableFunction<R, FunctionArguments...>(func);
-		}
+		CallableFunction<R, FunctionArguments...> callableFunction(func);
+		return std::move(callableFunction);
+	}

-	private:
-		const compiler::JITCompiler jit;
-		const Options options;
-	};
+private:
+	const compiler::JITCompiler jit;
+	const Options options;
+};
 } // namespace nautilus::engine
