From 2e856d08ea32f16c80681205551c96e31f49d4c7 Mon Sep 17 00:00:00 2001
From: lukas schwerdtfeger <lukas.schwerdtfeger@gmail.com>
Date: Fri, 2 Jan 2026 11:59:00 +0100
Subject: [PATCH] timing

---
 .../src/nautilus/compiler/JITCompiler.cpp     | 39 +++++++++++++++++++
 1 file changed, 39 insertions(+)

diff --git a/nautilus/src/nautilus/compiler/JITCompiler.cpp b/nautilus/src/nautilus/compiler/JITCompiler.cpp
index a9e8b9b..aa4ead3 100644
--- a/nautilus/src/nautilus/compiler/JITCompiler.cpp
+++ b/nautilus/src/nautilus/compiler/JITCompiler.cpp
@@ -63,25 +63,64 @@ std::string createCompilationUnitID() {
 std::unique_ptr<Executable> JITCompiler::compile(JITCompiler::wrapper_function function) const {
 	const CompilationUnitID compilationId = createCompilationUnitID();
 	auto dumpHandler = DumpHandler(options, compilationId);
+
+	// Timing instrumentation
+	auto start_total = std::chrono::high_resolution_clock::now();
+
 	// derive trace from function
+	auto start_tracing = std::chrono::high_resolution_clock::now();
 	auto executionTrace = tracing::TraceContext::trace(function, options);
+	auto end_tracing = std::chrono::high_resolution_clock::now();
+	auto tracing_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_tracing - start_tracing);
+
 	dumpHandler.dump("after_tracing", "trace", [&]() { return executionTrace->toString(); });
 
 	// create ssa
+	auto start_ssa = std::chrono::high_resolution_clock::now();
 	auto ssaCreationPhase = tracing::SSACreationPhase();
 	auto afterSSA = ssaCreationPhase.apply(std::move(executionTrace));
+	auto end_ssa = std::chrono::high_resolution_clock::now();
+	auto ssa_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_ssa - start_ssa);
+
 	dumpHandler.dump("after_ssa", "trace", [&]() { return afterSSA->toString(); });
+
 	// get nautilus ir from trace
+	auto start_ir = std::chrono::high_resolution_clock::now();
 	auto irGenerationPhase = tracing::TraceToIRConversionPhase();
 	const auto ir = irGenerationPhase.apply(std::move(afterSSA), compilationId);
+	auto end_ir = std::chrono::high_resolution_clock::now();
+	auto ir_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_ir - start_ir);
+
 	dumpHandler.dump("after_ir_creation", "ir", [&]() { return ir->toString(); });
 	if (options.getOptionOrDefault("dump.graph", false)) {
 		ir::createGraphVizFromIr(ir, options, dumpHandler);
 	}
+
 	// lower to backend
+	auto start_backend = std::chrono::high_resolution_clock::now();
 	const auto backendName = getName();
 	const auto backend = backends->getBackend(backendName);
 	auto executable = backend->compile(ir, dumpHandler, options);
+	auto end_backend = std::chrono::high_resolution_clock::now();
+	auto backend_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_backend - start_backend);
+
+	auto end_total = std::chrono::high_resolution_clock::now();
+	auto total_duration = std::chrono::duration_cast<std::chrono::microseconds>(end_total - start_total);
+
+	// Display latency breakdown
+	fmt::println(stderr, "\n=== Compilation Latency Breakdown ===");
+	fmt::println(stderr, "Tracing:      {:>10} us ({:>5.1f}%)", tracing_duration.count(),
+	             100.0 * tracing_duration.count() / total_duration.count());
+	fmt::println(stderr, "SSA Creation: {:>10} us ({:>5.1f}%)", ssa_duration.count(),
+	             100.0 * ssa_duration.count() / total_duration.count());
+	fmt::println(stderr, "IR Generation:{:>10} us ({:>5.1f}%)", ir_duration.count(),
+	             100.0 * ir_duration.count() / total_duration.count());
+	fmt::println(stderr, "Backend:      {:>10} us ({:>5.1f}%)", backend_duration.count(),
+	             100.0 * backend_duration.count() / total_duration.count());
+	fmt::println(stderr, "-------------------------------------");
+	fmt::println(stderr, "Total:        {:>10} us", total_duration.count());
+	fmt::println(stderr, "=====================================\n");
+
 	executable->setGeneratedFiles(dumpHandler.getGeneratedFiles());
 	return executable;
 }
-- 
2.50.0

