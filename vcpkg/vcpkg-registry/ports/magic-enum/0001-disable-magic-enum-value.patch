Index: include/magic_enum/magic_enum_utility.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/magic_enum/magic_enum_utility.hpp b/include/magic_enum/magic_enum_utility.hpp
--- a/include/magic_enum/magic_enum_utility.hpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/include/magic_enum/magic_enum_utility.hpp	(date 1756384063314)
@@ -78,61 +78,87 @@
 }

 template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
-[[nodiscard]] constexpr auto enum_next_value(E value, std::ptrdiff_t n = 1) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>> {
+[[nodiscard]] constexpr auto enum_next_value(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>> {
   using D = std::decay_t<E>;
   constexpr std::ptrdiff_t count = detail::count_v<D, S>;

   if (const auto i = enum_index<D, S>(value)) {
     const std::ptrdiff_t index = (static_cast<std::ptrdiff_t>(*i) + n);
     if (index >= 0 && index < count) {
-      return enum_value<D, S>(static_cast<std::size_t>(index));
+      return enum_value_accessor::enum_value<D, S>(static_cast<std::size_t>(index));
     }
   }
   return {};
 }
+  template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
+[[nodiscard]] constexpr auto enum_next_value(E value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>
+{
+  return enum_next_value<E>(value, 1);
+}
+

 template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
-[[nodiscard]] constexpr auto enum_next_value_circular(E value, std::ptrdiff_t n = 1) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
+[[nodiscard]] constexpr auto enum_next_value_circular(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
   using D = std::decay_t<E>;
   constexpr std::ptrdiff_t count = detail::count_v<D, S>;

   if (const auto i = enum_index<D, S>(value)) {
     const std::ptrdiff_t index = ((((static_cast<std::ptrdiff_t>(*i) + n) % count) + count) % count);
     if (index >= 0 && index < count) {
-      return enum_value<D, S>(static_cast<std::size_t>(index));
+      return enum_value_accessor::enum_value<D, S>(static_cast<std::size_t>(index));
     }
   }
   return MAGIC_ENUM_ASSERT(false), value;
 }

 template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
-[[nodiscard]] constexpr auto enum_prev_value(E value, std::ptrdiff_t n = 1) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>> {
+[[nodiscard]] constexpr auto enum_next_value_circular(E value) noexcept -> detail::enable_if_t<E, std::decay_t<E>>
+{
+  return enum_next_value_circular<E>(value, 1);
+}
+
+
+template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
+[[nodiscard]] constexpr auto enum_prev_value(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>> {
   using D = std::decay_t<E>;
   constexpr std::ptrdiff_t count = detail::count_v<D, S>;

   if (const auto i = enum_index<D, S>(value)) {
     const std::ptrdiff_t index = (static_cast<std::ptrdiff_t>(*i) - n);
     if (index >= 0 && index < count) {
-      return enum_value<D, S>(static_cast<std::size_t>(index));
+      return enum_value_accessor::enum_value<D, S>(static_cast<std::size_t>(index));
     }
   }
   return {};
 }

 template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
-[[nodiscard]] constexpr auto enum_prev_value_circular(E value, std::ptrdiff_t n = 1) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
+[[nodiscard]] constexpr auto enum_prev_value(E value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>
+{
+  return enum_prev_value<E>(value, 1);
+}
+
+template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
+[[nodiscard]] constexpr auto enum_prev_value_circular(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
   using D = std::decay_t<E>;
   constexpr std::ptrdiff_t count = detail::count_v<D, S>;

   if (const auto i = enum_index<D, S>(value)) {
     const std::ptrdiff_t index = ((((static_cast<std::ptrdiff_t>(*i) - n) % count) + count) % count);
     if (index >= 0 && index < count) {
-      return enum_value<D, S>(static_cast<std::size_t>(index));
+      return enum_value_accessor::enum_value<D, S>(static_cast<std::size_t>(index));
     }
   }
   return MAGIC_ENUM_ASSERT(false), value;
 }

+template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
+[[nodiscard]] constexpr auto enum_prev_value_circular(E value) noexcept -> detail::enable_if_t<E, std::decay_t<E>>
+{
+  return enum_prev_value_circular<E>(value, 1);
+}
+
+
 } // namespace magic_enum

 #endif // NEARGYE_MAGIC_ENUM_UTILITY_HPP
Index: test/test_flags.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/test_flags.cpp b/test/test_flags.cpp
--- a/test/test_flags.cpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/test/test_flags.cpp	(date 1756383755102)
@@ -347,30 +347,30 @@
 }

 TEST_CASE("enum_value") {
-  constexpr auto cr = enum_value<Color>(0);
+  constexpr auto cr = enum_cast<Color>(0);
   REQUIRE(cr == Color::RED);
-  REQUIRE(enum_value<Color&>(1) == Color::GREEN);
-  REQUIRE(enum_value<Color>(2) == Color::BLUE);
+  REQUIRE(enum_cast<Color&>(1) == Color::GREEN);
+  REQUIRE(enum_cast<Color>(2) == Color::BLUE);

   REQUIRE(enum_value<Color, 0>() == Color::RED);
   REQUIRE(enum_value<Color, 1>() == Color::GREEN);
   REQUIRE(enum_value<Color, 2>() == Color::BLUE);

-  constexpr auto no = enum_value<Numbers>(0);
+  constexpr auto no = enum_cast<Numbers>(0);
   REQUIRE(no == Numbers::one);
-  REQUIRE(enum_value<Numbers>(1) == Numbers::two);
-  REQUIRE(enum_value<Numbers>(2) == Numbers::three);
-  REQUIRE(enum_value<Numbers>(3) == Numbers::many);
+  REQUIRE(enum_cast<Numbers>(1) == Numbers::two);
+  REQUIRE(enum_cast<Numbers>(2) == Numbers::three);
+  REQUIRE(enum_cast<Numbers>(3) == Numbers::many);

   REQUIRE(enum_value<Numbers, 0>() == Numbers::one);
   REQUIRE(enum_value<Numbers, 1>() == Numbers::two);
   REQUIRE(enum_value<Numbers, 2>() == Numbers::three);
   REQUIRE(enum_value<Numbers, 3>() == Numbers::many);

-  constexpr auto dr = enum_value<Directions>(3);
-  REQUIRE(enum_value<Directions&>(0) == Directions::Left);
-  REQUIRE(enum_value<const Directions>(1) == Directions::Down);
-  REQUIRE(enum_value<Directions>(2) == Directions::Up);
+  constexpr auto dr = enum_cast<Directions>(3);
+  REQUIRE(enum_cast<Directions&>(0) == Directions::Left);
+  REQUIRE(enum_cast<const Directions>(1) == Directions::Down);
+  REQUIRE(enum_cast<Directions>(2) == Directions::Up);
   REQUIRE(dr == Directions::Right);

   REQUIRE(enum_value<Directions, 0>() == Directions::Left);
@@ -378,11 +378,11 @@
   REQUIRE(enum_value<Directions, 2>() == Directions::Up);
   REQUIRE(enum_value<Directions, 3>() == Directions::Right);

-  constexpr auto nt = enum_value<number>(2);
-  REQUIRE(enum_value<number>(0) == number::one);
-  REQUIRE(enum_value<number>(1) == number::two);
+  constexpr auto nt = enum_cast<number>(2);
+  REQUIRE(enum_cast<number>(0) == number::one);
+  REQUIRE(enum_cast<number>(1) == number::two);
   REQUIRE(nt == number::three);
-  REQUIRE(enum_value<number>(3) == number::four);
+  REQUIRE(enum_cast<number>(3) == number::four);

   REQUIRE(enum_value<number, 0>() == number::one);
   REQUIRE(enum_value<number, 1>() == number::two);
@@ -710,11 +710,11 @@
 template <typename E, E V>
 struct Foo {};

-TEST_CASE("constexpr_for") {
-  constexpr_for<0, magic_enum::enum_count<Color>(), 1>([](auto i) {
-    [[maybe_unused]] Foo<Color, magic_enum::enum_value<Color, i>()> bar{};
-  });
-}
+// TEST_CASE("constexpr_for") {
+//   constexpr_for<0, magic_enum::enum_count<Color>(), 1>([](auto i) {
+//     [[maybe_unused]] Foo<Color, magic_enum::enum_cast<Color>(i).value()> bar{};
+//   });
+// }

 #endif

Index: example/enum_flag_example.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/example/enum_flag_example.cpp b/example/enum_flag_example.cpp
--- a/example/enum_flag_example.cpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/example/enum_flag_example.cpp	(date 1756382960275)
@@ -72,7 +72,7 @@
   std::cout << "AnimalFlags enum size: " << magic_enum::enum_count<AnimalFlags>() << std::endl; // AnimalFlags enum size: 4

   // Indexed access to enum-flags value.
-  std::cout << "AnimalFlags[0] = " << magic_enum::enum_value<AnimalFlags>(0) << std::endl; // AnimalFlags[0] = HasClaws
+  std::cout << "AnimalFlags[0] = " << magic_enum::enum_cast<AnimalFlags>(0) << std::endl; // AnimalFlags[0] = HasClaws

   // Enum-flags value sequence.
   constexpr auto values = magic_enum::enum_values<AnimalFlags>();
Index: test/test.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/test.cpp b/test/test.cpp
--- a/test/test.cpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/test/test.cpp	(date 1756384023857)
@@ -394,28 +394,28 @@
 }

 TEST_CASE("enum_value") {
-  constexpr auto cr = enum_value<Color>(0);
+  constexpr auto cr = enum_cast<Color>(0);
   REQUIRE(cr == Color::RED);
-  REQUIRE(enum_value<Color&>(1) == Color::GREEN);
-  REQUIRE(enum_value<Color>(2) == Color::BLUE);
+  REQUIRE(enum_cast<Color&>(1) == Color::GREEN);
+  REQUIRE(enum_cast<Color>(2) == Color::BLUE);

   REQUIRE(enum_value<Color, 0>() == Color::RED);
   REQUIRE(enum_value<Color, 1>() == Color::GREEN);
   REQUIRE(enum_value<Color, 2>() == Color::BLUE);

-  constexpr auto no = enum_value<Numbers>(0);
+  constexpr auto no = enum_cast<Numbers>(0);
   REQUIRE(no == Numbers::one);
-  REQUIRE(enum_value<Numbers>(1) == Numbers::two);
-  REQUIRE(enum_value<Numbers>(2) == Numbers::three);
+  REQUIRE(enum_cast<Numbers>(1) == Numbers::two);
+  REQUIRE(enum_cast<Numbers>(2) == Numbers::three);

   REQUIRE(enum_value<Numbers, 0>() == Numbers::one);
   REQUIRE(enum_value<Numbers, 1>() == Numbers::two);
   REQUIRE(enum_value<Numbers, 2>() == Numbers::three);

-  constexpr auto dr = enum_value<Directions>(3);
-  REQUIRE(enum_value<Directions&>(0) == Directions::Left);
-  REQUIRE(enum_value<const Directions>(1) == Directions::Down);
-  REQUIRE(enum_value<Directions>(2) == Directions::Up);
+  constexpr auto dr = enum_cast<Directions>(3);
+  REQUIRE(enum_cast<Directions&>(0) == Directions::Left);
+  REQUIRE(enum_cast<const Directions>(1) == Directions::Down);
+  REQUIRE(enum_cast<Directions>(2) == Directions::Up);
   REQUIRE(dr == Directions::Right);

   REQUIRE(enum_value<Directions, 0>() == Directions::Left);
@@ -423,16 +423,16 @@
   REQUIRE(enum_value<Directions, 2>() == Directions::Up);
   REQUIRE(enum_value<Directions, 3>() == Directions::Right);

-  constexpr auto nt = enum_value<number>(2);
-  REQUIRE(enum_value<number>(0) == number::one);
-  REQUIRE(enum_value<number>(1) == number::two);
+  constexpr auto nt = enum_cast<number>(2);
+  REQUIRE(enum_cast<number>(0) == number::one);
+  REQUIRE(enum_cast<number>(1) == number::two);
   REQUIRE(nt == number::three);

   REQUIRE(enum_value<number, 0>() == number::one);
   REQUIRE(enum_value<number, 1>() == number::two);
   REQUIRE(enum_value<number, 2>() == number::three);

-  REQUIRE(enum_value<BoolTest>(0) == BoolTest::Yay);
+  REQUIRE(enum_cast<BoolTest>(0) == BoolTest::Yay);
   REQUIRE(enum_value<BoolTest, 0>() == BoolTest::Yay);
 }

Index: example/example.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/example/example.cpp b/example/example.cpp
--- a/example/example.cpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/example/example.cpp	(date 1756383357889)
@@ -78,7 +78,7 @@
   std::cout << "Color enum size: " << magic_enum::enum_count<Color>() << std::endl; // Color size: 3

   // Indexed access to enum value.
-  std::cout << "Color[0] = " << magic_enum::enum_value<Color>(0) << std::endl; // Color[0] = RED
+  std::cout << "Color[0] = " << magic_enum::enum_cast<Color>(0) << std::endl; // Color[0] = RED

   // Enum value sequence.
   constexpr auto values = magic_enum::enum_values<Color>();
Index: include/magic_enum/magic_enum_flags.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/magic_enum/magic_enum_flags.hpp b/include/magic_enum/magic_enum_flags.hpp
--- a/include/magic_enum/magic_enum_flags.hpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/include/magic_enum/magic_enum_flags.hpp	(date 1756384063288)
@@ -64,7 +64,7 @@
 // Returns name from enum-flags value.
 // If enum-flags value does not have name or value out of range, returns empty string.
 template <typename E>
-[[nodiscard]] auto enum_flags_name(E value, char_type sep = static_cast<char_type>('|')) -> detail::enable_if_t<E, string> {
+[[nodiscard]] auto enum_flags_name(E value, const char_type sep) -> detail::enable_if_t<E, string> {
   using D = std::decay_t<E>;
   using U = underlying_type_t<D>;
   constexpr auto S = detail::enum_subtype::flags;
@@ -73,7 +73,7 @@
   string name;
   auto check_value = U{0};
   for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
-    if (const auto v = static_cast<U>(enum_value<D, S>(i)); (static_cast<U>(value) & v) != 0) {
+    if (const auto v = static_cast<U>(enum_value_accessor::enum_value<D, S>(i)); (static_cast<U>(value) & v) != 0) {
       if (const auto n = detail::names_v<D, S>[i]; !n.empty()) {
         check_value |= v;
         if (!name.empty()) {
@@ -91,6 +91,11 @@
   }
   return {}; // Invalid value or out of range.
 }
+template <typename E>
+[[nodiscard]] auto enum_flags_name(E value) -> detail::enable_if_t<E, string>
+{
+  return enum_flags_name(value, '|');
+}

 // Obtains enum-flags value from integer value.
 // Returns optional with enum-flags value.
@@ -108,7 +113,7 @@
     if constexpr (detail::is_sparse_v<D, S>) {
       auto check_value = U{0};
       for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
-        if (const auto v = static_cast<U>(enum_value<D, S>(i)); (value & v) != 0) {
+        if (const auto v = static_cast<U>(enum_value_accessor::enum_value<D, S>(i)); (value & v) != 0) {
           check_value |= v;
         }
       }
@@ -131,7 +136,7 @@
 // Obtains enum-flags value from name.
 // Returns optional with enum-flags value.
 template <typename E, typename BinaryPredicate = std::equal_to<>>
-[[nodiscard]] constexpr auto enum_flags_cast(string_view value, [[maybe_unused]] BinaryPredicate p = {}) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate> {
+[[nodiscard]] constexpr auto enum_flags_cast(string_view value, BinaryPredicate p) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate> {
   using D = std::decay_t<E>;
   using U = underlying_type_t<D>;
   constexpr auto S = detail::enum_subtype::flags;
@@ -148,7 +153,7 @@
       auto f = U{0};
       for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
         if (detail::cmp_equal(s, detail::names_v<D, S>[i], p)) {
-          f = static_cast<U>(enum_value<D, S>(i));
+          f = static_cast<U>(enum_value_accessor::enum_value<D, S>(i));
           result |= f;
           break;
         }
@@ -166,6 +171,13 @@
   }
 }

+template <typename E, typename BinaryPredicate = std::equal_to<>>
+[[nodiscard]] constexpr auto enum_flags_cast(string_view value) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate>
+{
+  return enum_flags_cast<E>(value, BinaryPredicate{});
+}
+
+
 // Checks whether enum-flags contains value with such value.
 template <typename E>
 [[nodiscard]] constexpr auto enum_flags_contains(E value) noexcept -> detail::enable_if_t<E, bool> {
Index: include/magic_enum/magic_enum.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/include/magic_enum/magic_enum.hpp b/include/magic_enum/magic_enum.hpp
--- a/include/magic_enum/magic_enum.hpp	(revision d468f23408f1207a4c63b370bb34e4cfabffad83)
+++ b/include/magic_enum/magic_enum.hpp	(date 1756384063305)
@@ -1231,22 +1231,68 @@
   return detail::count_v<std::decay_t<E>, S>;
 }

-// Returns enum value at specified index.
-// No bounds checking is performed: the behavior is undefined if index >= number of enum values.
-template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
-[[nodiscard]] constexpr auto enum_value(std::size_t index) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
-  using D = std::decay_t<E>;
-  static_assert(detail::is_reflected_v<D, S>, "magic_enum requires enum implementation and valid max and min.");
+// Block direct usage of enum_value, as this can fail if given value is out of range. Use magic_enum::enum_cast instead!
+class enum_value_accessor
+{
+  // Returns enum value at specified index.
+  // No bounds checking is performed: the behavior is undefined if index >= number of enum values.
+  template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
+  [[nodiscard]] static constexpr auto enum_value(std::size_t index) noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
+    using D = std::decay_t<E>;
+    static_assert(detail::is_reflected_v<D, S>, "magic_enum requires enum implementation and valid max and min.");

-  if constexpr (detail::is_sparse_v<D, S>) {
-    return MAGIC_ENUM_ASSERT(index < detail::count_v<D, S>), detail::values_v<D, S>[index];
-  } else {
-    constexpr auto min = (S == detail::enum_subtype::flags) ? detail::log2(detail::min_v<D, S>) : detail::min_v<D, S>;
+    if constexpr (detail::is_sparse_v<D, S>) {
+      return MAGIC_ENUM_ASSERT(index < detail::count_v<D, S>), detail::values_v<D, S>[index];
+    } else {
+      constexpr auto min = (S == detail::enum_subtype::flags) ? detail::log2(detail::min_v<D, S>) : detail::min_v<D, S>;

-    return MAGIC_ENUM_ASSERT(index < detail::count_v<D, S>), detail::value<D, min, S>(index);
-  }
-}
+      return MAGIC_ENUM_ASSERT(index < detail::count_v<D, S>), detail::value<D, min, S>(index);
+    }
+  }

+  // Friend declarations for internal usage
+  template <typename E, detail::enum_subtype S>
+  friend constexpr auto enum_index(E value) noexcept -> detail::enable_if_t<E, optional<std::size_t>>;
+
+  template <typename E, detail::enum_subtype S>
+  friend constexpr auto enum_cast(underlying_type_t<E> value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+
+  template <typename E, detail::enum_subtype S, typename BinaryPredicate>
+  friend constexpr auto enum_cast(
+      string_view value,
+      BinaryPredicate p
+  ) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate>;
+
+  template <typename E>
+  friend auto enum_flags_name(E value, char_type sep) -> detail::enable_if_t<E, string>;
+
+  template <typename E>
+  friend constexpr auto enum_flags_cast(underlying_type_t<E> value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+
+  template <typename E, typename BinaryPredicate>
+  friend constexpr auto enum_flags_cast(
+      string_view value,
+      BinaryPredicate p
+  ) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate>;
+
+  template <typename E, typename BinaryPredicate>
+  friend constexpr auto enum_flags_cast(
+      string_view value
+  ) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate>;
+
+  template <typename E, std::size_t I, detail::enum_subtype S> friend constexpr auto enum_value() noexcept -> detail::enable_if_t<E, std::decay_t<E>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_prev_value(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_prev_value_circular(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, std::decay_t<E>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_next_value(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_next_value_circular(E value, std::ptrdiff_t n) noexcept -> detail::enable_if_t<E, std::decay_t<E>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_prev_value(E value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_prev_value_circular(E value) noexcept -> detail::enable_if_t<E, std::decay_t<E>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_next_value(E value) noexcept -> detail::enable_if_t<E, optional<std::decay_t<E>>>;
+  template <typename E, detail::enum_subtype S> friend constexpr auto enum_next_value_circular(E value) noexcept -> detail::enable_if_t<E, std::decay_t<E>>;
+};
+
+
+
 // Returns enum value at specified index.
 template <typename E, std::size_t I, detail::enum_subtype S = detail::subtype_v<E>>
 [[nodiscard]] constexpr auto enum_value() noexcept -> detail::enable_if_t<E, std::decay_t<E>> {
@@ -1254,7 +1300,7 @@
   static_assert(detail::is_reflected_v<D, S>, "magic_enum requires enum implementation and valid max and min.");
   static_assert(I < detail::count_v<D, S>, "magic_enum::enum_value out of range.");

-  return enum_value<D, S>(I);
+  return enum_value_accessor::enum_value<D, S>(I);
 }

 // Returns std::array with enum values, sorted by enum value.
@@ -1294,7 +1340,7 @@
         detail::default_result_type_lambda<optional<std::size_t>>);
 #else
     for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
-      if (enum_value<D, S>(i) == value) {
+      if (enum_value_accessor::enum_value<D, S>(i) == value) {
         return i;
       }
     }
@@ -1399,7 +1445,7 @@
         detail::default_result_type_lambda<optional<D>>);
 #else
     for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
-      if (value == static_cast<underlying_type_t<D>>(enum_value<D, S>(i))) {
+      if (value == static_cast<underlying_type_t<D>>(enum_value_accessor::enum_value<D, S>(i))) {
         return static_cast<D>(value);
       }
     }
@@ -1416,7 +1462,7 @@
 // Obtains enum value from name.
 // Returns optional with enum value.
 template <typename E, detail::enum_subtype S = detail::subtype_v<E>, typename BinaryPredicate = std::equal_to<>>
-[[nodiscard]] constexpr auto enum_cast(string_view value, [[maybe_unused]] BinaryPredicate p = {}) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate> {
+[[nodiscard]] constexpr auto enum_cast(string_view value, [[maybe_unused]] BinaryPredicate p) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate> {
   using D = std::decay_t<E>;
   static_assert(detail::is_reflected_v<D, S>, "magic_enum requires enum implementation and valid max and min.");

@@ -1431,12 +1477,16 @@
 #endif
   for (std::size_t i = 0; i < detail::count_v<D, S>; ++i) {
     if (detail::cmp_equal(value, detail::names_v<D, S>[i], p)) {
-      return enum_value<D, S>(i);
+      return enum_value_accessor::enum_value<D, S>(i);
     }
   }
   return {}; // Invalid value or out of range.
 }
-
+template <typename E, detail::enum_subtype S = detail::subtype_v<E>, typename BinaryPredicate = std::equal_to<>>
+[[nodiscard]] constexpr auto enum_cast(string_view value) noexcept(detail::is_nothrow_invocable_v<BinaryPredicate>) -> detail::enable_if_t<E, optional<std::decay_t<E>>, BinaryPredicate>
+{
+  return enum_cast<E>(value, BinaryPredicate{});
+}
 // Checks whether enum contains value with such value.
 template <typename E, detail::enum_subtype S = detail::subtype_v<E>>
 [[nodiscard]] constexpr auto enum_contains(E value) noexcept -> detail::enable_if_t<E, bool> {
