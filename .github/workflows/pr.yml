name: NES PR CI

# The following pipeline is meant to run for every PR. It will not call any other workflow / pipeline.
# It will also apply the format check. If these steps are successful, it will try to build the PR and run the tests.
# In the future, we will add more automated checks to this pipeline, e.g., clang-tidy for our codebase or code coverage checks.

on:
  pull_request:
    branches:
      - "main"
      - "feature/**"
    paths-ignore:
      - README.md
      - CODE_OF_CONDUCT.md
      - CHANGELOG.md
      - 'docs/**'
    # The ready_for_review event is used when a draft pr is changed into a non-draft version. If we did
    # not use the ready_for_review the ci would not be triggered and appear to have passed.
    types: [ ready_for_review, synchronize, opened, reopened ]

jobs:
  validateTrigger:
    # This ensures we won't run the CI if it is in draft mode.
    if: ${{ !github.event.pull_request.draft }}
    runs-on: [ self-hosted, linux, Build ]
    steps:
      - uses: actions/checkout@v4
      - name: Contextual QA Checklists
        uses: wyozi/contextual-qa-checklist-action@1.3.2
        with:
          gh-token: ${{ secrets.NES_CI_SECRET }}
          comment-header: "Thank you for your PR. Please pay attention to the following items before merging:"
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.12.1
        with:
          access_token: ${{ secrets.NES_CI_SECRET }}

  detect-dependency-changes:
    # This job detects changes to files relevant for our dependency management
    # If no changes are detected the docker image build jobs are skipped
    # This job also determines the development image tag used for building and testing
    # If no changes are detected we can use the `latest` tag which refers to the last
    # development image based on the main branch
    # If changes are detected we use a branch-specific tag
    name: Detect changes to dependencies
    outputs:
      change: ${{steps.changed-files.outputs.any_modified}}
      tag: ${{ steps.image-tag.outputs.tag }}
    runs-on: [ self-hosted, linux, Build ]
    steps:
      - uses: actions/checkout@v4
      - name: Looking for changed dependency files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            vcpkg/**
            docker/dependency/**
      - name: Choose Image Tag for CI
        id: image-tag
        env:
          ANY_MODIFIED: ${{ steps.changed-files.outputs.any_modified }}
          ALL_MODIFIED: ${{ steps.changed-files.outputs.all_modified_files }}
        run: |
          for file in ${ALL_MODIFIED}; do
            echo "$file was modified"
          done
          if [[ "$ANY_MODIFIED" == "true" ]]
          then
            echo "tag=${{ github.event.pull_request.head.ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=latest" >> "$GITHUB_OUTPUT"
          fi

  docker-development-images-pre:
    # We run the docker image build on separate machines and combine them into a single
    # multi-platform docker image in the docker-development-images job.
    # The Docker build uses a cache based on previous branch-specific images or the
    # main branch
    # This job builds a Base image which contains the llvm based toolchain and a recent
    # CMake version
    # The Dependency Image contains a pre-built sdk based on the vcpkg manifest
    # The Development Image contains the dependencies and additional tooling like clang-format.
    name: "Build Development Images"
    needs: [ validateTrigger, detect-dependency-changes ]
    if: needs.detect-dependency-changes.outputs.change == 'true'
    runs-on: [ self-hosted, linux, Build, "${{ matrix.platform }}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64, arm64 ]
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER_NAME }}
          password: ${{ secrets.DOCKER_SECRET }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build Base Image
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: nebulastream/nes-development-base:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
          cache-to: type=registry,ref=nebulastream/nes-development-base-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}},mode=max
          cache-from: |
            type=registry,ref=nebulastream/nes-development-base-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
            type=registry,ref=nebulastream/nes-development-base-cache:latest-${{matrix.platform}}
          context: .
          file: docker/dependency/Base.dockerfile
      - name: Build Dependency Image
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: nebulastream/nes-development-dependency:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
          cache-to: type=registry,ref=nebulastream/nes-development-dependency-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}},mode=max
          cache-from: |
            type=registry,ref=nebulastream/nes-development-dependency-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
            type=registry,ref=nebulastream/nes-development-dependency-cache:latest-${{matrix.platform}}
          build-args: |
            TAG=${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
            ARCH=${{matrix.platform}}
          context: .
          file: docker/dependency/Dependency.dockerfile
      - name: Build Development Image
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: nebulastream/nes-development:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
          cache-to: type=registry,ref=nebulastream/nes-development-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}},mode=max
          cache-from: |
            type=registry,ref=nebulastream/nes-development-cache:${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
            type=registry,ref=nebulastream/nes-development-dependency-cache:latest-${{matrix.platform}}
          build-args: TAG=${{ github.event.pull_request.head.ref }}-${{matrix.platform}}
          context: .
          file: docker/dependency/Development.dockerfile

  docker-development-images:
    # This job merges platform specific images into a single multi-platform image
    name: "Merge images for different platforms into a single Multi-Platform image"
    needs: [ docker-development-images-pre, detect-dependency-changes ]
    if: needs.detect-dependency-changes.outputs.change == 'true'
    runs-on: [ self-hosted, linux, Build ]
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        if: ${{ !env.act }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER_NAME }}
          password: ${{ secrets.DOCKER_SECRET }}
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Combine Manifests
        run: |
          docker buildx imagetools create -t nebulastream/nes-development-base:${{ github.event.pull_request.head.ref }} \
            nebulastream/nes-development-base:${{ github.event.pull_request.head.ref }}-x64 \
            nebulastream/nes-development-base:${{ github.event.pull_request.head.ref }}-arm64

          docker buildx imagetools create -t nebulastream/nes-development-dependency:${{ github.event.pull_request.head.ref }} \
            nebulastream/nes-development-dependency:${{ github.event.pull_request.head.ref }}-x64 \
            nebulastream/nes-development-dependency:${{ github.event.pull_request.head.ref }}-arm64

          docker buildx imagetools create -t nebulastream/nes-development:${{ github.event.pull_request.head.ref }} \
            nebulastream/nes-development:${{ github.event.pull_request.head.ref }}-x64 \
            nebulastream/nes-development:${{ github.event.pull_request.head.ref }}-arm64


  pre-build-checks:
    needs: [ docker-development-images, detect-dependency-changes ]
    if: ${{ ! failure() && ! cancelled() }}
    runs-on: [ self-hosted, linux, Build ]
    container:
      image: nebulastream/nes-development:${{ needs.detect-dependency-changes.outputs.tag }}
      options: --user root
    steps:
      - uses: actions/checkout@v4
      - name: Configure CMake
        run: cmake -B build
      - name: check-preamble
        run: |
          cmake --build build --target check-preamble
          if [ $? -ne 0 ]; then
            echo "'check-preamble' (available as a local target) failed. There are files that miss the license preamble and/or '#pragma once'."
            exit 1
          fi
      - name: check-format
        run: |
          cmake --build build --target check-format
          if ! git diff --quiet; then
            git status  # print unformatted files
            echo "Please build 'check-format' target locally before shipping your changes on remote"
            exit 1
          fi
      - name: check-comment-format
        run: |
          cmake --build build --target check-comment-format
          if [ $? -ne 0 ]; then
            echo "Please build 'check-comment-format' target locally before shipping your changes on remote"
            exit 1
          fi

  build-linux:
    name: "Build ${{matrix.platform}}"
    if: ${{ ! failure() && ! cancelled() }}
    needs: [ docker-development-images , detect-dependency-changes ]
    container:
      image: nebulastream/nes-development:${{ needs.detect-dependency-changes.outputs.tag }}
      volumes:
        - ccache:/ccache
      env:
        CCACHE_DIR: /ccache
      options: --user root
    timeout-minutes: 40
    runs-on: [ self-hosted, linux, Build, "${{matrix.platform}}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64, arm64 ]
    steps:
      - uses: actions/checkout@v4
      - name: Configure NebulaStream
        run: cmake -GNinja -B build -DNES_USE_CCACHE=ON
      - name: Build NebulaStream
        run: cmake --build build -j -- -k 0
      - name: Run Tests
        run: ctest --test-dir build -j --output-on-failure

  run_code_coverage:
    name: "Run Code Coverage"
    uses: ./.github/workflows/code_coverage.yml
    secrets: inherit