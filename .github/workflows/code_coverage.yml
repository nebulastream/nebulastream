# This workflow is triggered by the pr.yml workflow.
# We are using this workflow to build the code coverage for the base branch and PR branches.
# We do this by building all tests for the base and PR branches and comparing the code coverage between the two branches.
# To get the code coverage, we use the code-coverage-action from barecheck that operates on lcov files generated by building with the flag CODE_COVERAGE=ON and running the tests.
# The test have a timeout of 40 minutes, as building the code coverage can take a long time.
name: Code Coverage

on:
  # We are using this yaml in other workflows, e.g., nightly or PR, so we need to allow another workflow call to trigger this workflow.
  # We are expecting the tag of the docker image to be passed as an output from the previous job.
  workflow_call:
    inputs:
      base_dev_image_tag:
        required: true
        type: string
        description: "Docker image tag of the development image of the base branch"
      dev_image_tag:
        required: true
        type: string
        description: "Docker image tag of the development image of the head commit"
      head_sha:
        required: true
        type: string
        description: "Commit sha of head"
      base_sha:
        required: true
        type: string
        description: "Commit sha of base"
      number_of_commits:
        required: true
        type: number
        description: distance between base and head

jobs:
  build-code-coverage-ref:
    container:
      image: nebulastream/nes-ci:${{ inputs.base_dev_image_tag }}
      volumes:
        - ccache:/ccache
      env:
        CCACHE_DIR: /ccache
      # TODO #401 Investigate rootless docker containers
      options: --user root
    timeout-minutes: 40
    runs-on: [ self-hosted, linux, Build, "${{matrix.platform}}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64 ]
    # We build the test coverage for the provided base branch
    steps:
      - name: Cache Ref Branch Coverage
        uses: actions/cache@v3
        id: ref-cov-cache
        with:
          path: /tmp/cov-cache/
          key: ${{ matrix.platform }}-ref-cov-${{ inputs.base_sha }}
      - if: ${{ steps.ref-cov-cache.outputs.cache-hit != 'true' }}
        uses:
          AutoModality/action-clean@v1
      - name: Checkout Base Branch
        if: ${{ steps.ref-cov-cache.outputs.cache-hit != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.base_sha }}
      - name: Build base coverage if not in cache
        if: ${{ steps.ref-cov-cache.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p build
          cmake -GNinja -DCODE_COVERAGE=ON -B build
          cmake --build build -j -- -k 0
          cmake --build build --target ccov-all-export
          mkdir -p /tmp/cov-cache/
          cp build/ccov/coverage.lcov /tmp/cov-cache/ref-coverage.lcov
      - name: Upload code coverage for ref branch
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}-ref-cov-${{ inputs.base_sha }}.info
          path: /tmp/cov-cache/ref-coverage.lcov

  build-code-coverage-pr-branch:
    container:
      image: nebulastream/nes-ci:${{ inputs.dev_image_tag }}
      volumes:
        - ccache:/ccache
      env:
        CCACHE_DIR: /ccache
      # TODO #401 Investigate rootless docker containers
      options: --user root
    timeout-minutes: 40
    runs-on: [ self-hosted, linux, Build, "${{matrix.platform}}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64 ]
    steps:
      - name: Cache PR Branch Coverage
        uses: actions/cache@v3
        id: pr-cov-cache
        with:
          path: /tmp/cov-cache/
          key: ${{ matrix.platform }}-pr-cov-${{ inputs.head_sha }}
      - name: Include base commit
        if: ${{ steps.pr-cov-cache.outputs.cache-hit != 'true' }}
        id: increment
        run: echo "result=$((${{ inputs.number_of_commits }} + 1))" >> $GITHUB_OUTPUT
      - name: Checkout PR Branch
        if: ${{ steps.pr-cov-cache.outputs.cache-hit != 'true' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: ${{ steps.increment.outputs.result }}
      - name: Build coverage and export as lcov if not in cache
        if: ${{ steps.pr-cov-cache.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p build
          cmake -DCODE_COVERAGE:BOOL=ON -B build
          cmake --build build -j -- -k 0
          cmake --build build --target ccov-all-export
          mkdir -p /tmp/cov-cache/
          cp build/ccov/coverage.lcov /tmp/cov-cache/pr-coverage.lcov
      # We need to call the build target ccov-all to generate the html files for the code coverage
      # We need them as we want to copy the html files of the changed files to the cache such that they can be
      # uploaded as an artifact. This helps the reviewers to see the code coverage of the changed files.
      - name: Build coverage and export as html if not in cache
        if: ${{ steps.pr-cov-cache.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p build
          cmake -DCODE_COVERAGE:BOOL=ON -B build
          cmake --build build -j -- -k 0
          cmake --build build --target ccov-all
      - name: Copy code coverage of changed files
        if: ${{ steps.pr-cov-cache.outputs.cache-hit != 'true' }}
        run: |
          mkdir -p /tmp/cov-cache/code-coverage-${{ matrix.platform }}
          rm -rf /tmp/cov-cache/code-coverage-${{ matrix.platform }}/*
          
          filepath_style_css=$(find build -name "style.css" -print)
          cp "${filepath_style_css}" "/tmp/cov-cache/code-coverage-${{ matrix.platform }}/."
          echo "Copying ${filepath_style_css} to /tmp/cov-cache/code-coverage-${{ matrix.platform }}."
          
          # We only want to copy the html files of the changed files to the cache
          # Otherwise, we would copy all html files, which would be a lot of data and we run into the data limit of github.
          for file in $(git diff --name-status ${{ inputs.head_sha }} ${{ inputs.base_sha }}); do
            base_name=$(basename ${file})
            filepath=$(find build -name "${base_name}.html" -print)
            echo "Outside of the loop: <${filepath}<"
            if [ -n "filepath" ]; then
              for found_file in ${filepath}; do
                sed -i "s#href='\(\.\.\/\)*style\.css'#href='style.css'#g" "${found_file}"
                cp "${found_file}" "/tmp/cov-cache/code-coverage-${{ matrix.platform }}/."
                echo "Copying ${found_file} to /tmp/cov-cache/code-coverage-${{ matrix.platform }}."
              done 
            fi
          done
      - name: Upload Code Coverage Summary
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-${{ matrix.platform }}
          path: /tmp/cov-cache/code-coverage-${{ matrix.platform }}
      - name: Upload code coverage for PR branch
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}-pr-cov-${{ inputs.head_sha }}.info
          path: /tmp/cov-cache/pr-coverage.lcov
  

  # For now, we build the code coverage for x64 only
  build-code-coverage:
    needs: [ build-code-coverage-ref, build-code-coverage-pr-branch ]
    if: ${{ github.event_name == 'pull_request' }}
    container:
      image: nebulastream/nes-ci:${{ inputs.dev_image_tag }}
      # TODO #401 Investigate rootless docker containers
      options: --user root
    timeout-minutes: 40
    runs-on: [ self-hosted, linux, Build, "${{matrix.platform}}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64 ]
    steps:
      - name: Downloading code coverage for ref branch
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.platform }}-ref-cov-${{ inputs.base_sha }}.info
      - name: Downloading code coverage for pr branch
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.platform }}-pr-cov-${{ inputs.head_sha }}.info
      # Comparing the code coverage from the current branch with the base branch
      - name: Generate Code Coverage Report
        id: code-coverage
        uses: barecheck/code-coverage-action@v1
        with:
          barecheck-github-app-token: ${{ secrets.BARECHECK_GITHUB_APP_TOKEN }}
          lcov-file: pr-coverage.lcov
          base-lcov-file: ref-coverage.lcov
          send-summary-comment: true
          show-annotations: "warning"


  create_sticky_note:
    needs: [ build-code-coverage-ref, build-code-coverage-pr-branch ]
    if: ${{ github.event_name == 'pull_request' }}
    container:
      image: nebulastream/nes-ci:${{ inputs.dev_image_tag }}
      # TODO #401 Investigate rootless docker containers
      options: --user root
    timeout-minutes: 40
    runs-on: [ self-hosted, linux, Build, "${{matrix.platform}}" ]
    strategy:
      fail-fast: false
      matrix:
        platform: [ x64 ]
    steps:
      - name: Create Sticky Note Action URL
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          append: false
          message: |
            CI Action Job: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
