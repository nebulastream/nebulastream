# name: union/Union.test
# description: Simple union tests
# groups: [Union, CompilationIntensive]

CREATE LOGICAL SOURCE stream(id UINT64, value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream TYPE File;
ATTACH INLINE
1,1,1000
1,1,1001
1,1,1002
1,1,1003

CREATE LOGICAL SOURCE stream2(id UINT64, value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream2 TYPE File;
ATTACH INLINE
2,2,2000
2,2,2001
2,2,2002
2,2,2003

CREATE LOGICAL SOURCE stream3(id UINT64, id2 UINT64, value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream3 TYPE File;
ATTACH INLINE
1,2,2,3000
1,2,2,3001
1,2,2,3002
1,2,2,3003

CREATE LOGICAL SOURCE stream3_1(id2 UINT64, value2 UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream3_1 TYPE File;
ATTACH INLINE
1,1,1005
1,1,1008
2,2,2005
2,2,2006

CREATE SINK sink(id UINT64, value UINT64, timestamp UINT64)  TYPE File;

# Simple Union
SELECT * FROM stream UNION SELECT * FROM stream2 INTO sink;
----
1,1,1000
1,1,1001
1,1,1002
1,1,1003
2,2,2000
2,2,2001
2,2,2002
2,2,2003

# Union with projection to fixup the schema
SELECT * FROM stream UNION SELECT id2 as id, value, timestamp FROM stream3 INTO sink;
----
1,1,1000
1,1,1001
1,1,1002
1,1,1003
2,2,3000
2,2,3001
2,2,3002
2,2,3003

CREATE SINK sink2(timestamp UINT64, origin UINT8)  TYPE File;
# Union with selection to fixup the schema and projection of constant into the schema
SELECT timestamp, UINT8(1) as origin FROM stream UNION SELECT timestamp, UINT8(2) as origin FROM stream WHERE timestamp < UINT64(1002) INTO sink2;
----
1000,1
1001,1
1002,1
1003,1
1000,2
1001,2

# nested union with projection to fixup the schema
SELECT * FROM stream UNION SELECT * FROM stream2 UNION SELECT id2 as id, value, timestamp FROM stream3 INTO sink;
----
1,1,1000
1,1,1001
1,1,1002
1,1,1003
2,2,2000
2,2,2001
2,2,2002
2,2,2003
2,2,3000
2,2,3001
2,2,3002
2,2,3003

CREATE SINK sink3(timestamp UINT64)  TYPE File;

# nested union with projection to fixup the schema
SELECT timestamp
FROM (
    SELECT * FROM stream UNION SELECT * FROM stream
)
INTO sink3;
----
1000
1001
1002
1003
1000
1001
1002
1003

# CURRENTLY WindowAggregation and Unions are broken in the sense that an EoS will not flush the window state!

CREATE LOGICAL SOURCE stream4(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream4 TYPE File;
ATTACH INLINE
1,1000
12,1001
32,1002
1,2001

CREATE LOGICAL SOURCE stream5(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream5 TYPE File;
ATTACH INLINE
65,1000
21,1001
3,1002
2,2001

CREATE SINK sink4(max_value UINT64)  TYPE File;
SELECT MAX(value) as max_value
FROM (
    SELECT * FROM stream4 UNION SELECT * FROM stream5
)
WINDOW TUMBLING(timestamp, size 1 sec)
INTO sink4;
----
65
2

CREATE SINK sink5(start UINT64, end UINT64, id UINT64, value UINT64, timestamp UINT64, id2 UINT64, value2 UINT64, timestamp UINT64) TYPE File;

SELECT *
FROM (SELECT * FROM (SELECT * FROM stream UNION SELECT * FROM stream2))
INNER JOIN (SELECT * FROM stream3_1)
ON (id = id2)
WINDOW TUMBLING (timestamp, size 1 sec)
INTO sink5;
----
1000,2000,1,1,1000,1,1,1005
1000,2000,1,1,1001,1,1,1005
1000,2000,1,1,1002,1,1,1005
1000,2000,1,1,1003,1,1,1005
1000,2000,1,1,1000,1,1,1008
1000,2000,1,1,1001,1,1,1008
1000,2000,1,1,1002,1,1,1008
1000,2000,1,1,1003,1,1,1008
2000,3000,2,2,2000,2,2,2005
2000,3000,2,2,2001,2,2,2005
2000,3000,2,2,2002,2,2,2005
2000,3000,2,2,2003,2,2,2005
2000,3000,2,2,2000,2,2,2006
2000,3000,2,2,2001,2,2,2006
2000,3000,2,2,2002,2,2,2006
2000,3000,2,2,2003,2,2,2006



# This demonstrates that all pending windows are triggered at the end of the execution
CREATE LOGICAL SOURCE stream6(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream6 TYPE File;
ATTACH INLINE
1,1000
12,1001
32,1002
1,1003

CREATE LOGICAL SOURCE stream7(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream7 TYPE File;
ATTACH INLINE
65,1000
21,1001
3,1002
2,2003

CREATE SINK sink5(max_value UINT64)  TYPE File;
SELECT MAX(value) as max_value
FROM (
    SELECT * FROM stream6 UNION SELECT * FROM stream7
)
WINDOW TUMBLING(timestamp, size 1 sec)
INTO sink4;
----
65
2

# This demonstrates that the previous test still works when a union is nested in a projection
CREATE LOGICAL SOURCE stream8(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream8 TYPE File;
ATTACH INLINE
1,1000
12,1001
32,1002
1,1003

CREATE LOGICAL SOURCE stream9(value UINT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR stream9 TYPE File;
ATTACH INLINE
65,1000
21,1001
3,1002
2,2003

CREATE SINK sink6(max_value UINT64)  TYPE File;
SELECT MAX(value) as max_value
FROM (
    SELECT * FROM (SELECT * FROM stream8 UNION SELECT * FROM stream9)
)
WINDOW TUMBLING(timestamp, size 1 sec)
INTO sink6;
----
65
2

CREATE SINK subquery_sink(timestamp UINT64)  TYPE File;
# triple union query as a subquery as a nested query.
SELECT timestamp
FROM (
    SELECT * FROM stream UNION SELECT * FROM stream UNION SELECT * FROM stream
)
INTO subquery_sink;
----
1000
1001
1002
1003
1000
1001
1002
1003
1000
1001
1002
1003
