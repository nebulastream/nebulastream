# name: milestone/DEBS.test
# description: Queries from our DEBS tutorial
# groups: [milestone, benchmark, benchmark_small]

# Source definitions
CREATE LOGICAL SOURCE solarPanels(producerId INT32, groupId INT32, producedPower FLOAT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR solarPanels TYPE File;
ATTACH FILE small/debs/SOLAR_PANELS_TOPIC_100K.csv

CREATE LOGICAL SOURCE windTurbines(producerId INT32, groupId INT32, producedPower FLOAT64, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR windTurbines TYPE File;
ATTACH FILE small/debs/WIND_TURBINES_TOPIC_100K.csv

CREATE LOGICAL SOURCE consumers(consumerId INT32, sectorId INT32, consumedPower FLOAT64, consumerType VARSIZED, timestamp UINT64);
CREATE PHYSICAL SOURCE FOR consumers TYPE File;
ATTACH FILE small/debs/CONSUMERS_TOPIC_100K.csv

CREATE SINK consumersChecksum(consumers.consumerId INT32, consumers.sectorId INT32, consumers.consumedPower FLOAT64, consumers.consumerType VARSIZED, consumers.timestamp UINT64)  TYPE Checksum;
CREATE SINK solarPanelsChecksum(solarPanels.producerId INT32, solarPanels.groupId INT32, solarPanels.producedPower FLOAT64, solarPanels.timestamp UINT64)  TYPE Checksum;
CREATE SINK q4Checksum(consumedPower FLOAT64)  TYPE Checksum;
CREATE SINK q5Checksum(producerId INT32, groupId INT32, producedPower FLOAT64, ts UINT64)  TYPE Checksum;
CREATE SINK q6Checksum(source UINT64, producerId INT32, groupId INT32, producedPower FLOAT64, ts UINT64)  TYPE Checksum;
CREATE SINK winPowerProductionChecksum(solarPanels.start UINT64, solarPanels.end UINT64, solarPanels.groupId INT32, solarPanels.producedPower FLOAT64)  TYPE Checksum;

# Query 0a - Simple Source Sink with consumers stream
SELECT * FROM consumers INTO consumersChecksum;
----
2716 6530006

# Query 0b - Simple Source Sink with solarPanels stream
SELECT * FROM solarPanels INTO solarPanelsChecksum;
----
3147 5126576

# Query 1 - Filter tuples
SELECT * FROM consumers WHERE consumedPower >= FLOAT64(400) INTO consumersChecksum;
----
914 2207295

# Query 2 - Filter with multiple attributes
SELECT * FROM consumers WHERE consumedPower >= FLOAT64(400) AND sectorId = INT32(1) INTO consumersChecksum;
----
215 526222

# Query 3 - Filter with complex expression
SELECT * FROM consumers WHERE consumedPower >= FLOAT64(1) AND consumedPower < FLOAT64(61) INTO consumersChecksum;
----
257 607868

# Query 4 - Filter with complex expression
SELECT consumedPower / FLOAT64(1000) AS consumedPower FROM consumers INTO q4Checksum;
----
2716 975461

# Query 5 - Union Queries
# Results are verified using: https://gist.github.com/ls-1801/d03e4cfbe2957efdace1efe075c5fb95
SELECT
    producerId,
    groupId,
    producedPower,
    timestamp as ts
FROM windTurbines
UNION
SELECT
    producerId,
    groupId,
    producedPower,
    timestamp as ts
FROM solarPanels
INTO q5Checksum;
----
7026 9829536

# Query 6 - More union with additional projection to distinguish between union streams
# Results are verified using: https://gist.github.com/ls-1801/d03e4cfbe2957efdace1efe075c5fb95
SELECT
    source,
    producerId,
    groupId,
    producedPower,
    timestamp as ts
FROM (
    SELECT *, UINT64(1) AS source
    FROM windTurbines
        UNION
    SELECT *, UINT64(2) AS source
    FROM solarPanels
)
INTO q6Checksum;
----
7026 10486101

# Query 7 - Window aggregations with tumbling windows
SELECT start, end, groupId, SUM(producedPower) AS producedPower
FROM solarPanels
GROUP BY groupId
WINDOW TUMBLING(timestamp, SIZE 1 HOUR)
INTO winPowerProductionChecksum;
----
148 264615

# Query 8 - Window aggregations with sliding windows
SELECT start, end, groupId, SUM(producedPower) AS producedPower
FROM solarPanels
GROUP BY groupId
WINDOW SLIDING(timestamp, SIZE 1 HOUR, ADVANCE BY 10 MINUTES)
INTO winPowerProductionChecksum;
----
884 1581808
