
// Generated from /home/rudi/dima/nebulastream-public/nes-nebuli/parser/NebulaSQL.g4 by ANTLR 4.13.2


#include "NebulaSQLListener.h"

#include "NebulaSQLParser.h"


#include <Util/DisableWarningsPragma.hpp>
DISABLE_WARNING_PUSH
DISABLE_WARNING(-Wlogical - op - parentheses)
DISABLE_WARNING(-Wunused - parameter)


using namespace antlrcpp;

using namespace antlr4;

namespace
{

struct NebulaSQLParserStaticData final
{
    NebulaSQLParserStaticData(
        std::vector<std::string> ruleNames, std::vector<std::string> literalNames, std::vector<std::string> symbolicNames)
        : ruleNames(std::move(ruleNames))
        , literalNames(std::move(literalNames))
        , symbolicNames(std::move(symbolicNames))
        , vocabulary(this->literalNames, this->symbolicNames)
    {
    }

    NebulaSQLParserStaticData(const NebulaSQLParserStaticData&) = delete;
    NebulaSQLParserStaticData(NebulaSQLParserStaticData&&) = delete;
    NebulaSQLParserStaticData& operator=(const NebulaSQLParserStaticData&) = delete;
    NebulaSQLParserStaticData& operator=(NebulaSQLParserStaticData&&) = delete;

    std::vector<antlr4::dfa::DFA> decisionToDFA;
    antlr4::atn::PredictionContextCache sharedContextCache;
    const std::vector<std::string> ruleNames;
    const std::vector<std::string> literalNames;
    const std::vector<std::string> symbolicNames;
    const antlr4::dfa::Vocabulary vocabulary;
    antlr4::atn::SerializedATNView serializedATN;
    std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag nebulasqlParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
    std::unique_ptr<NebulaSQLParserStaticData>
        nebulasqlParserStaticData = nullptr;

void nebulasqlParserInitialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    if (nebulasqlParserStaticData != nullptr)
    {
        return;
    }
#else
    assert(nebulasqlParserStaticData == nullptr);
#endif
    auto staticData = std::make_unique<NebulaSQLParserStaticData>(
        std::vector<std::string>{
            "singleStatement",
            "statement",
            "query",
            "queryOrganization",
            "queryTerm",
            "queryPrimary",
            "querySpecification",
            "fromClause",
            "relation",
            "joinRelation",
            "joinType",
            "joinCriteria",
            "relationPrimary",
            "functionTable",
            "fromStatement",
            "fromStatementBody",
            "selectClause",
            "whereClause",
            "havingClause",
            "inlineTable",
            "tableAlias",
            "multipartIdentifierList",
            "multipartIdentifier",
            "namedExpression",
            "identifier",
            "strictIdentifier",
            "quotedIdentifier",
            "identifierList",
            "identifierSeq",
            "errorCapturingIdentifier",
            "errorCapturingIdentifierExtra",
            "namedExpressionSeq",
            "expression",
            "booleanExpression",
            "windowedAggregationClause",
            "aggregationClause",
            "groupingSet",
            "windowClause",
            "watermarkClause",
            "watermarkParameters",
            "windowSpec",
            "timeWindow",
            "countWindow",
            "conditionWindow",
            "conditionParameter",
            "thresholdMinSizeParameter",
            "sizeParameter",
            "advancebyParameter",
            "timeUnit",
            "timestampParameter",
            "functionName",
            "sinkClause",
            "sink",
            "nullNotnull",
            "streamName",
            "fileFormat",
            "sortItem",
            "predicate",
            "valueExpression",
            "comparisonOperator",
            "hint",
            "hintStatement",
            "primaryExpression",
            "qualifiedName",
            "number",
            "constant",
            "booleanValue",
            "strictNonReserved",
            "ansiNonReserved",
            "nonReserved"},
        std::vector<std::string>{
            "",
            "';'",
            "','",
            "'('",
            "')'",
            "'.'",
            "'/*+'",
            "'*/'",
            "",
            "",
            "",
            "'ANY'",
            "",
            "",
            "'AT'",
            "",
            "",
            "'COMMENT'",
            "'CUBE'",
            "'DELETE'",
            "",
            "'DISTINCT'",
            "'DIV'",
            "'DROP'",
            "'ELSE'",
            "'END'",
            "'ESCAPE'",
            "'EXISTS'",
            "'FALSE'",
            "'FIRST'",
            "'FOR'",
            "",
            "'FULL'",
            "",
            "'GROUPING'",
            "",
            "'IF'",
            "",
            "",
            "",
            "",
            "",
            "",
            "'LAST'",
            "'LEFT'",
            "'LIKE'",
            "",
            "'LIST'",
            "",
            "'NATURAL'",
            "",
            "'NULL'",
            "'NULLS'",
            "'OF'",
            "",
            "",
            "",
            "'QUERY'",
            "'RECOVER'",
            "'RIGHT'",
            "",
            "'ROLLUP'",
            "",
            "'SETS'",
            "'SOME'",
            "'START'",
            "'TABLE'",
            "'TO'",
            "'TRUE'",
            "'TYPE'",
            "",
            "'UNKNOWN'",
            "'USE'",
            "'USING'",
            "'VALUES'",
            "'WHEN'",
            "",
            "",
            "'WITH'",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "'File'",
            "'Print'",
            "",
            "'CSV_FORMAT'",
            "'AT_MOST_ONCE'",
            "'AT_LEAST_ONCE'",
            "",
            "",
            "'<=>'",
            "'<>'",
            "'!='",
            "'<'",
            "",
            "'>'",
            "",
            "'+'",
            "'-'",
            "'*'",
            "'/'",
            "'%'",
            "'~'",
            "'&'",
            "'|'",
            "'||'",
            "'^'"},
        std::vector<std::string>{
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "BACKQUOTED_IDENTIFIER",
            "ALL",
            "AND",
            "ANY",
            "AS",
            "ASC",
            "AT",
            "BETWEEN",
            "BY",
            "COMMENT",
            "CUBE",
            "DELETE",
            "DESC",
            "DISTINCT",
            "DIV",
            "DROP",
            "ELSE",
            "END",
            "ESCAPE",
            "EXISTS",
            "FALSE",
            "FIRST",
            "FOR",
            "FROM",
            "FULL",
            "GROUP",
            "GROUPING",
            "HAVING",
            "IF",
            "IN",
            "INNER",
            "INSERT",
            "INTO",
            "IS",
            "JOIN",
            "LAST",
            "LEFT",
            "LIKE",
            "LIMIT",
            "LIST",
            "MERGE",
            "NATURAL",
            "NOT",
            "NULLTOKEN",
            "NULLS",
            "OF",
            "ON",
            "OR",
            "ORDER",
            "QUERY",
            "RECOVER",
            "RIGHT",
            "RLIKE",
            "ROLLUP",
            "SELECT",
            "SETS",
            "SOME",
            "START",
            "TABLE",
            "TO",
            "TRUE",
            "TYPE",
            "UNION",
            "UNKNOWN",
            "USE",
            "USING",
            "VALUES",
            "WHEN",
            "WHERE",
            "WINDOW",
            "WITH",
            "TUMBLING",
            "SLIDING",
            "THRESHOLD",
            "SIZE",
            "ADVANCE",
            "MS",
            "SEC",
            "MIN",
            "HOUR",
            "DAY",
            "MAX",
            "AVG",
            "SUM",
            "COUNT",
            "MEDIAN",
            "WATERMARK",
            "OFFSET",
            "FILE",
            "PRINT",
            "LOCALHOST",
            "CSV_FORMAT",
            "AT_MOST_ONCE",
            "AT_LEAST_ONCE",
            "BOOLEAN_VALUE",
            "EQ",
            "NSEQ",
            "NEQ",
            "NEQJ",
            "LT",
            "LTE",
            "GT",
            "GTE",
            "PLUS",
            "MINUS",
            "ASTERISK",
            "SLASH",
            "PERCENT",
            "TILDE",
            "AMPERSAND",
            "PIPE",
            "CONCAT_PIPE",
            "HAT",
            "STRING",
            "BIGINT_LITERAL",
            "SMALLINT_LITERAL",
            "TINYINT_LITERAL",
            "INTEGER_VALUE",
            "UNSIGNED_SMALLINT_LITERAL",
            "UNSIGNED_TINYINT_LITERAL",
            "UNSIGNED_INTEGER_VALUE",
            "UNSIGNED_BIGINT_LITERAL",
            "EXPONENT_VALUE",
            "DECIMAL_VALUE",
            "FLOAT_LITERAL",
            "DOUBLE_LITERAL",
            "BIGDECIMAL_LITERAL",
            "IDENTIFIER",
            "SIMPLE_COMMENT",
            "BRACKETED_COMMENT",
            "WS",
            "FOUR_OCTETS",
            "OCTET",
            "UNRECOGNIZED"});
    static const int32_t serializedATNSegment[]
        = {4,   1,   141, 881, 2,   0,   7,   0,   2,   1,   7,   1,   2,   2,   7,   2,   2,   3,   7,   3,   2,   4,   7,   4,   2,   5,
           7,   5,   2,   6,   7,   6,   2,   7,   7,   7,   2,   8,   7,   8,   2,   9,   7,   9,   2,   10,  7,   10,  2,   11,  7,   11,
           2,   12,  7,   12,  2,   13,  7,   13,  2,   14,  7,   14,  2,   15,  7,   15,  2,   16,  7,   16,  2,   17,  7,   17,  2,   18,
           7,   18,  2,   19,  7,   19,  2,   20,  7,   20,  2,   21,  7,   21,  2,   22,  7,   22,  2,   23,  7,   23,  2,   24,  7,   24,
           2,   25,  7,   25,  2,   26,  7,   26,  2,   27,  7,   27,  2,   28,  7,   28,  2,   29,  7,   29,  2,   30,  7,   30,  2,   31,
           7,   31,  2,   32,  7,   32,  2,   33,  7,   33,  2,   34,  7,   34,  2,   35,  7,   35,  2,   36,  7,   36,  2,   37,  7,   37,
           2,   38,  7,   38,  2,   39,  7,   39,  2,   40,  7,   40,  2,   41,  7,   41,  2,   42,  7,   42,  2,   43,  7,   43,  2,   44,
           7,   44,  2,   45,  7,   45,  2,   46,  7,   46,  2,   47,  7,   47,  2,   48,  7,   48,  2,   49,  7,   49,  2,   50,  7,   50,
           2,   51,  7,   51,  2,   52,  7,   52,  2,   53,  7,   53,  2,   54,  7,   54,  2,   55,  7,   55,  2,   56,  7,   56,  2,   57,
           7,   57,  2,   58,  7,   58,  2,   59,  7,   59,  2,   60,  7,   60,  2,   61,  7,   61,  2,   62,  7,   62,  2,   63,  7,   63,
           2,   64,  7,   64,  2,   65,  7,   65,  2,   66,  7,   66,  2,   67,  7,   67,  2,   68,  7,   68,  2,   69,  7,   69,  1,   0,
           1,   0,   5,   0,   143, 8,   0,   10,  0,   12,  0,   146, 9,   0,   1,   0,   1,   0,   1,   1,   1,   1,   1,   2,   1,   2,
           1,   2,   1,   3,   1,   3,   1,   3,   1,   3,   1,   3,   5,   3,   160, 8,   3,   10,  3,   12,  3,   163, 9,   3,   3,   3,
           165, 8,   3,   1,   3,   1,   3,   1,   3,   3,   3,   170, 8,   3,   3,   3,   172, 8,   3,   1,   3,   1,   3,   3,   3,   176,
           8,   3,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   1,   4,   5,   4,   184, 8,   4,   10,  4,   12,  4,   187, 9,   4,
           1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   1,   5,   3,   5,   198, 8,   5,   1,   6,   1,
           6,   1,   6,   3,   6,   203, 8,   6,   1,   6,   3,   6,   206, 8,   6,   1,   6,   3,   6,   209, 8,   6,   1,   6,   3,   6,
           212, 8,   6,   1,   7,   1,   7,   1,   7,   1,   7,   5,   7,   218, 8,   7,   10,  7,   12,  7,   221, 9,   7,   1,   8,   1,
           8,   5,   8,   225, 8,   8,   10,  8,   12,  8,   228, 9,   8,   1,   9,   1,   9,   1,   9,   1,   9,   3,   9,   234, 8,   9,
           1,   9,   1,   9,   1,   9,   1,   9,   1,   9,   3,   9,   241, 8,   9,   1,   10,  3,   10,  244, 8,   10,  1,   11,  1,   11,
           1,   11,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,  1,   12,
           1,   12,  1,   12,  1,   12,  3,   12,  264, 8,   12,  1,   13,  1,   13,  1,   13,  1,   13,  1,   13,  5,   13,  271, 8,   13,
           10,  13,  12,  13,  274, 9,   13,  3,   13,  276, 8,   13,  1,   13,  1,   13,  1,   13,  1,   14,  1,   14,  4,   14,  283, 8,
           14,  11,  14,  12,  14,  284, 1,   15,  1,   15,  3,   15,  289, 8,   15,  1,   15,  3,   15,  292, 8,   15,  1,   16,  1,   16,
           5,   16,  296, 8,   16,  10,  16,  12,  16,  299, 9,   16,  1,   16,  1,   16,  1,   17,  1,   17,  1,   17,  1,   18,  1,   18,
           1,   18,  1,   19,  1,   19,  1,   19,  1,   19,  5,   19,  313, 8,   19,  10,  19,  12,  19,  316, 9,   19,  1,   19,  1,   19,
           1,   20,  3,   20,  321, 8,   20,  1,   20,  1,   20,  3,   20,  325, 8,   20,  3,   20,  327, 8,   20,  1,   21,  1,   21,  1,
           21,  5,   21,  332, 8,   21,  10,  21,  12,  21,  335, 9,   21,  1,   22,  1,   22,  1,   22,  5,   22,  340, 8,   22,  10,  22,
           12,  22,  343, 9,   22,  1,   23,  1,   23,  3,   23,  347, 8,   23,  1,   23,  1,   23,  3,   23,  351, 8,   23,  3,   23,  353,
           8,   23,  1,   24,  1,   24,  1,   24,  3,   24,  358, 8,   24,  1,   25,  1,   25,  1,   25,  1,   25,  1,   25,  1,   25,  3,
           25,  366, 8,   25,  1,   26,  1,   26,  1,   27,  1,   27,  1,   27,  1,   27,  1,   28,  1,   28,  1,   28,  5,   28,  377, 8,
           28,  10,  28,  12,  28,  380, 9,   28,  1,   29,  1,   29,  1,   29,  1,   30,  1,   30,  4,   30,  387, 8,   30,  11,  30,  12,
           30,  388, 1,   30,  3,   30,  392, 8,   30,  1,   31,  1,   31,  1,   31,  5,   31,  397, 8,   31,  10,  31,  12,  31,  400, 9,
           31,  1,   32,  1,   32,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  3,
           33,  414, 8,   33,  3,   33,  416, 8,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  1,   33,  5,   33,  424, 8,   33,
           10,  33,  12,  33,  427, 9,   33,  1,   34,  3,   34,  430, 8,   34,  1,   34,  1,   34,  3,   34,  434, 8,   34,  1,   35,  1,
           35,  1,   35,  1,   35,  1,   35,  5,   35,  441, 8,   35,  10,  35,  12,  35,  444, 9,   35,  1,   35,  1,   35,  1,   35,  1,
           35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  5,   35,  456, 8,   35,  10,  35,  12,  35,  459, 9,   35,  1,
           35,  1,   35,  3,   35,  463, 8,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  1,   35,  5,   35,
           473, 8,   35,  10,  35,  12,  35,  476, 9,   35,  1,   35,  1,   35,  3,   35,  480, 8,   35,  1,   36,  1,   36,  1,   36,  1,
           36,  5,   36,  486, 8,   36,  10,  36,  12,  36,  489, 9,   36,  3,   36,  491, 8,   36,  1,   36,  1,   36,  3,   36,  495, 8,
           36,  1,   37,  1,   37,  1,   37,  1,   38,  1,   38,  1,   38,  1,   38,  1,   38,  1,   39,  1,   39,  1,   39,  1,   39,  1,
           39,  1,   40,  1,   40,  1,   40,  3,   40,  513, 8,   40,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  3,   41,  520, 8,
           41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  1,   41,  3,   41,  530, 8,   41,  1,   41,  1,   41,
           1,   41,  1,   41,  1,   41,  3,   41,  537, 8,   41,  1,   42,  1,   42,  1,   42,  1,   42,  1,   42,  1,   43,  1,   43,  1,
           43,  1,   43,  1,   43,  3,   43,  549, 8,   43,  1,   43,  1,   43,  1,   44,  1,   44,  1,   45,  1,   45,  1,   46,  1,   46,
           1,   46,  1,   46,  1,   47,  1,   47,  1,   47,  1,   47,  1,   47,  1,   48,  1,   48,  1,   49,  1,   49,  1,   50,  1,   50,
           1,   51,  1,   51,  1,   51,  1,   51,  5,   51,  576, 8,   51,  10,  51,  12,  51,  579, 9,   51,  1,   52,  1,   52,  1,   53,
           3,   53,  584, 8,   53,  1,   53,  1,   53,  1,   54,  1,   54,  1,   55,  1,   55,  1,   56,  1,   56,  3,   56,  594, 8,   56,
           1,   56,  1,   56,  3,   56,  598, 8,   56,  1,   57,  3,   57,  601, 8,   57,  1,   57,  1,   57,  1,   57,  1,   57,  1,   57,
           1,   57,  3,   57,  609, 8,   57,  1,   57,  1,   57,  1,   57,  1,   57,  1,   57,  5,   57,  616, 8,   57,  10,  57,  12,  57,
           619, 9,   57,  1,   57,  1,   57,  1,   57,  3,   57,  624, 8,   57,  1,   57,  1,   57,  1,   57,  1,   57,  1,   57,  1,   57,
           3,   57,  632, 8,   57,  1,   57,  1,   57,  1,   57,  3,   57,  637, 8,   57,  1,   57,  1,   57,  1,   57,  1,   57,  1,   57,
           1,   57,  1,   57,  1,   57,  5,   57,  647, 8,   57,  10,  57,  12,  57,  650, 9,   57,  1,   57,  1,   57,  3,   57,  654, 8,
           57,  1,   57,  3,   57,  657, 8,   57,  1,   57,  1,   57,  1,   57,  1,   57,  3,   57,  663, 8,   57,  1,   57,  1,   57,  1,
           57,  1,   57,  3,   57,  669, 8,   57,  1,   57,  1,   57,  1,   57,  3,   57,  674, 8,   57,  1,   57,  1,   57,  1,   57,  3,
           57,  679, 8,   57,  1,   58,  1,   58,  1,   58,  1,   58,  3,   58,  685, 8,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,
           58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,   58,  1,
           58,  1,   58,  5,   58,  706, 8,   58,  10,  58,  12,  58,  709, 9,   58,  1,   59,  1,   59,  1,   60,  1,   60,  1,   60,  3,
           60,  716, 8,   60,  1,   60,  5,   60,  719, 8,   60,  10,  60,  12,  60,  722, 9,   60,  1,   60,  1,   60,  1,   61,  1,   61,
           1,   61,  1,   61,  1,   61,  1,   61,  5,   61,  732, 8,   61,  10,  61,  12,  61,  735, 9,   61,  1,   61,  1,   61,  3,   61,
           739, 8,   61,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,
           62,  1,   62,  1,   62,  4,   62,  755, 8,   62,  11,  62,  12,  62,  756, 1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  1,
           62,  1,   62,  5,   62,  766, 8,   62,  10,  62,  12,  62,  769, 9,   62,  3,   62,  771, 8,   62,  1,   62,  1,   62,  1,   62,
           1,   62,  1,   62,  1,   62,  1,   62,  1,   62,  3,   62,  781, 8,   62,  1,   62,  1,   62,  1,   62,  5,   62,  786, 8,   62,
           10,  62,  12,  62,  789, 9,   62,  1,   63,  1,   63,  1,   63,  5,   63,  794, 8,   63,  10,  63,  12,  63,  797, 9,   63,  1,
           64,  1,   64,  3,   64,  801, 8,   64,  1,   64,  1,   64,  1,   64,  3,   64,  806, 8,   64,  1,   64,  1,   64,  1,   64,  3,
           64,  811, 8,   64,  1,   64,  1,   64,  3,   64,  815, 8,   64,  1,   64,  1,   64,  3,   64,  819, 8,   64,  1,   64,  1,   64,
           3,   64,  823, 8,   64,  1,   64,  1,   64,  3,   64,  827, 8,   64,  1,   64,  1,   64,  3,   64,  831, 8,   64,  1,   64,  1,
           64,  3,   64,  835, 8,   64,  1,   64,  1,   64,  3,   64,  839, 8,   64,  1,   64,  1,   64,  3,   64,  843, 8,   64,  1,   64,
           1,   64,  3,   64,  847, 8,   64,  1,   64,  1,   64,  3,   64,  851, 8,   64,  1,   64,  1,   64,  3,   64,  855, 8,   64,  1,
           64,  3,   64,  858, 8,   64,  1,   65,  1,   65,  1,   65,  1,   65,  1,   65,  1,   65,  1,   65,  4,   65,  867, 8,   65,  11,
           65,  12,  65,  868, 3,   65,  871, 8,   65,  1,   66,  1,   66,  1,   67,  1,   67,  1,   68,  1,   68,  1,   69,  1,   69,  1,
           69,  0,   4,   8,   66,  116, 124, 70,  0,   2,   4,   6,   8,   10,  12,  14,  16,  18,  20,  22,  24,  26,  28,  30,  32,  34,
           36,  38,  40,  42,  44,  46,  48,  50,  52,  54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,  80,  82,  84,  86,
           88,  90,  92,  94,  96,  98,  100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
           0,   15,  1,   0,   84,  88,  2,   0,   86,  86,  89,  93,  2,   0,   13,  13,  20,  20,  2,   0,   29,  29,  43,  43,  3,   0,
           9,   9,   11,  11,  64,  64,  3,   0,   28,  28,  68,  68,  71,  71,  2,   0,   111, 112, 116, 116, 2,   0,   22,  22,  113, 115,
           2,   0,   111, 112, 119, 119, 1,   0,   103, 110, 1,   0,   130, 131, 2,   0,   28,  28,  68,  68,  9,   0,   32,  32,  38,  38,
           42,  42,  44,  44,  49,  49,  54,  54,  59,  59,  70,  70,  73,  73,  17,  0,   13,  16,  18,  20,  22,  23,  27,  27,  29,  29,
           34,  34,  39,  39,  43,  43,  45,  46,  48,  48,  52,  52,  57,  57,  60,  61,  63,  63,  68,  69,  74,  74,  77,  77,  17,  0,
           9,   16,  18,  23,  26,  29,  31,  31,  33,  35,  37,  37,  39,  41,  43,  43,  45,  46,  48,  48,  50,  52,  55,  57,  60,  64,
           66,  66,  68,  69,  74,  74,  76,  78,  959, 0,   140, 1,   0,   0,   0,   2,   149, 1,   0,   0,   0,   4,   151, 1,   0,   0,
           0,   6,   164, 1,   0,   0,   0,   8,   177, 1,   0,   0,   0,   10,  197, 1,   0,   0,   0,   12,  199, 1,   0,   0,   0,   14,
           213, 1,   0,   0,   0,   16,  222, 1,   0,   0,   0,   18,  240, 1,   0,   0,   0,   20,  243, 1,   0,   0,   0,   22,  245, 1,
           0,   0,   0,   24,  263, 1,   0,   0,   0,   26,  265, 1,   0,   0,   0,   28,  280, 1,   0,   0,   0,   30,  286, 1,   0,   0,
           0,   32,  293, 1,   0,   0,   0,   34,  302, 1,   0,   0,   0,   36,  305, 1,   0,   0,   0,   38,  308, 1,   0,   0,   0,   40,
           326, 1,   0,   0,   0,   42,  328, 1,   0,   0,   0,   44,  336, 1,   0,   0,   0,   46,  344, 1,   0,   0,   0,   48,  357, 1,
           0,   0,   0,   50,  365, 1,   0,   0,   0,   52,  367, 1,   0,   0,   0,   54,  369, 1,   0,   0,   0,   56,  373, 1,   0,   0,
           0,   58,  381, 1,   0,   0,   0,   60,  391, 1,   0,   0,   0,   62,  393, 1,   0,   0,   0,   64,  401, 1,   0,   0,   0,   66,
           415, 1,   0,   0,   0,   68,  429, 1,   0,   0,   0,   70,  479, 1,   0,   0,   0,   72,  494, 1,   0,   0,   0,   74,  496, 1,
           0,   0,   0,   76,  499, 1,   0,   0,   0,   78,  504, 1,   0,   0,   0,   80,  512, 1,   0,   0,   0,   82,  536, 1,   0,   0,
           0,   84,  538, 1,   0,   0,   0,   86,  543, 1,   0,   0,   0,   88,  552, 1,   0,   0,   0,   90,  554, 1,   0,   0,   0,   92,
           556, 1,   0,   0,   0,   94,  560, 1,   0,   0,   0,   96,  565, 1,   0,   0,   0,   98,  567, 1,   0,   0,   0,   100, 569, 1,
           0,   0,   0,   102, 571, 1,   0,   0,   0,   104, 580, 1,   0,   0,   0,   106, 583, 1,   0,   0,   0,   108, 587, 1,   0,   0,
           0,   110, 589, 1,   0,   0,   0,   112, 591, 1,   0,   0,   0,   114, 678, 1,   0,   0,   0,   116, 684, 1,   0,   0,   0,   118,
           710, 1,   0,   0,   0,   120, 712, 1,   0,   0,   0,   122, 738, 1,   0,   0,   0,   124, 780, 1,   0,   0,   0,   126, 790, 1,
           0,   0,   0,   128, 857, 1,   0,   0,   0,   130, 870, 1,   0,   0,   0,   132, 872, 1,   0,   0,   0,   134, 874, 1,   0,   0,
           0,   136, 876, 1,   0,   0,   0,   138, 878, 1,   0,   0,   0,   140, 144, 3,   2,   1,   0,   141, 143, 5,   1,   0,   0,   142,
           141, 1,   0,   0,   0,   143, 146, 1,   0,   0,   0,   144, 142, 1,   0,   0,   0,   144, 145, 1,   0,   0,   0,   145, 147, 1,
           0,   0,   0,   146, 144, 1,   0,   0,   0,   147, 148, 5,   0,   0,   1,   148, 1,   1,   0,   0,   0,   149, 150, 3,   4,   2,
           0,   150, 3,   1,   0,   0,   0,   151, 152, 3,   8,   4,   0,   152, 153, 3,   6,   3,   0,   153, 5,   1,   0,   0,   0,   154,
           155, 5,   56,  0,   0,   155, 156, 5,   16,  0,   0,   156, 161, 3,   112, 56,  0,   157, 158, 5,   2,   0,   0,   158, 160, 3,
           112, 56,  0,   159, 157, 1,   0,   0,   0,   160, 163, 1,   0,   0,   0,   161, 159, 1,   0,   0,   0,   161, 162, 1,   0,   0,
           0,   162, 165, 1,   0,   0,   0,   163, 161, 1,   0,   0,   0,   164, 154, 1,   0,   0,   0,   164, 165, 1,   0,   0,   0,   165,
           171, 1,   0,   0,   0,   166, 169, 5,   46,  0,   0,   167, 170, 5,   9,   0,   0,   168, 170, 5,   125, 0,   0,   169, 167, 1,
           0,   0,   0,   169, 168, 1,   0,   0,   0,   170, 172, 1,   0,   0,   0,   171, 166, 1,   0,   0,   0,   171, 172, 1,   0,   0,
           0,   172, 175, 1,   0,   0,   0,   173, 174, 5,   95,  0,   0,   174, 176, 5,   125, 0,   0,   175, 173, 1,   0,   0,   0,   175,
           176, 1,   0,   0,   0,   176, 7,   1,   0,   0,   0,   177, 178, 6,   4,   -1,  0,   178, 179, 3,   10,  5,   0,   179, 185, 1,
           0,   0,   0,   180, 181, 10,  1,   0,   0,   181, 182, 5,   70,  0,   0,   182, 184, 3,   8,   4,   2,   183, 180, 1,   0,   0,
           0,   184, 187, 1,   0,   0,   0,   185, 183, 1,   0,   0,   0,   185, 186, 1,   0,   0,   0,   186, 9,   1,   0,   0,   0,   187,
           185, 1,   0,   0,   0,   188, 198, 3,   12,  6,   0,   189, 198, 3,   28,  14,  0,   190, 191, 5,   66,  0,   0,   191, 198, 3,
           44,  22,  0,   192, 198, 3,   38,  19,  0,   193, 194, 5,   3,   0,   0,   194, 195, 3,   4,   2,   0,   195, 196, 5,   4,   0,
           0,   196, 198, 1,   0,   0,   0,   197, 188, 1,   0,   0,   0,   197, 189, 1,   0,   0,   0,   197, 190, 1,   0,   0,   0,   197,
           192, 1,   0,   0,   0,   197, 193, 1,   0,   0,   0,   198, 11,  1,   0,   0,   0,   199, 200, 3,   32,  16,  0,   200, 202, 3,
           14,  7,   0,   201, 203, 3,   34,  17,  0,   202, 201, 1,   0,   0,   0,   202, 203, 1,   0,   0,   0,   203, 205, 1,   0,   0,
           0,   204, 206, 3,   68,  34,  0,   205, 204, 1,   0,   0,   0,   205, 206, 1,   0,   0,   0,   206, 208, 1,   0,   0,   0,   207,
           209, 3,   36,  18,  0,   208, 207, 1,   0,   0,   0,   208, 209, 1,   0,   0,   0,   209, 211, 1,   0,   0,   0,   210, 212, 3,
           102, 51,  0,   211, 210, 1,   0,   0,   0,   211, 212, 1,   0,   0,   0,   212, 13,  1,   0,   0,   0,   213, 214, 5,   31,  0,
           0,   214, 219, 3,   16,  8,   0,   215, 216, 5,   2,   0,   0,   216, 218, 3,   16,  8,   0,   217, 215, 1,   0,   0,   0,   218,
           221, 1,   0,   0,   0,   219, 217, 1,   0,   0,   0,   219, 220, 1,   0,   0,   0,   220, 15,  1,   0,   0,   0,   221, 219, 1,
           0,   0,   0,   222, 226, 3,   24,  12,  0,   223, 225, 3,   18,  9,   0,   224, 223, 1,   0,   0,   0,   225, 228, 1,   0,   0,
           0,   226, 224, 1,   0,   0,   0,   226, 227, 1,   0,   0,   0,   227, 17,  1,   0,   0,   0,   228, 226, 1,   0,   0,   0,   229,
           230, 3,   20,  10,  0,   230, 231, 5,   42,  0,   0,   231, 233, 3,   24,  12,  0,   232, 234, 3,   22,  11,  0,   233, 232, 1,
           0,   0,   0,   233, 234, 1,   0,   0,   0,   234, 241, 1,   0,   0,   0,   235, 236, 5,   49,  0,   0,   236, 237, 3,   20,  10,
           0,   237, 238, 5,   42,  0,   0,   238, 239, 3,   24,  12,  0,   239, 241, 1,   0,   0,   0,   240, 229, 1,   0,   0,   0,   240,
           235, 1,   0,   0,   0,   241, 19,  1,   0,   0,   0,   242, 244, 5,   38,  0,   0,   243, 242, 1,   0,   0,   0,   243, 244, 1,
           0,   0,   0,   244, 21,  1,   0,   0,   0,   245, 246, 5,   54,  0,   0,   246, 247, 3,   66,  33,  0,   247, 23,  1,   0,   0,
           0,   248, 249, 3,   44,  22,  0,   249, 250, 3,   40,  20,  0,   250, 264, 1,   0,   0,   0,   251, 252, 5,   3,   0,   0,   252,
           253, 3,   4,   2,   0,   253, 254, 5,   4,   0,   0,   254, 255, 3,   40,  20,  0,   255, 264, 1,   0,   0,   0,   256, 257, 5,
           3,   0,   0,   257, 258, 3,   16,  8,   0,   258, 259, 5,   4,   0,   0,   259, 260, 3,   40,  20,  0,   260, 264, 1,   0,   0,
           0,   261, 264, 3,   38,  19,  0,   262, 264, 3,   26,  13,  0,   263, 248, 1,   0,   0,   0,   263, 251, 1,   0,   0,   0,   263,
           256, 1,   0,   0,   0,   263, 261, 1,   0,   0,   0,   263, 262, 1,   0,   0,   0,   264, 25,  1,   0,   0,   0,   265, 266, 3,
           58,  29,  0,   266, 275, 5,   3,   0,   0,   267, 272, 3,   64,  32,  0,   268, 269, 5,   2,   0,   0,   269, 271, 3,   64,  32,
           0,   270, 268, 1,   0,   0,   0,   271, 274, 1,   0,   0,   0,   272, 270, 1,   0,   0,   0,   272, 273, 1,   0,   0,   0,   273,
           276, 1,   0,   0,   0,   274, 272, 1,   0,   0,   0,   275, 267, 1,   0,   0,   0,   275, 276, 1,   0,   0,   0,   276, 277, 1,
           0,   0,   0,   277, 278, 5,   4,   0,   0,   278, 279, 3,   40,  20,  0,   279, 27,  1,   0,   0,   0,   280, 282, 3,   14,  7,
           0,   281, 283, 3,   30,  15,  0,   282, 281, 1,   0,   0,   0,   283, 284, 1,   0,   0,   0,   284, 282, 1,   0,   0,   0,   284,
           285, 1,   0,   0,   0,   285, 29,  1,   0,   0,   0,   286, 288, 3,   32,  16,  0,   287, 289, 3,   34,  17,  0,   288, 287, 1,
           0,   0,   0,   288, 289, 1,   0,   0,   0,   289, 291, 1,   0,   0,   0,   290, 292, 3,   70,  35,  0,   291, 290, 1,   0,   0,
           0,   291, 292, 1,   0,   0,   0,   292, 31,  1,   0,   0,   0,   293, 297, 5,   62,  0,   0,   294, 296, 3,   120, 60,  0,   295,
           294, 1,   0,   0,   0,   296, 299, 1,   0,   0,   0,   297, 295, 1,   0,   0,   0,   297, 298, 1,   0,   0,   0,   298, 300, 1,
           0,   0,   0,   299, 297, 1,   0,   0,   0,   300, 301, 3,   62,  31,  0,   301, 33,  1,   0,   0,   0,   302, 303, 5,   76,  0,
           0,   303, 304, 3,   66,  33,  0,   304, 35,  1,   0,   0,   0,   305, 306, 5,   35,  0,   0,   306, 307, 3,   66,  33,  0,   307,
           37,  1,   0,   0,   0,   308, 309, 5,   74,  0,   0,   309, 314, 3,   64,  32,  0,   310, 311, 5,   2,   0,   0,   311, 313, 3,
           64,  32,  0,   312, 310, 1,   0,   0,   0,   313, 316, 1,   0,   0,   0,   314, 312, 1,   0,   0,   0,   314, 315, 1,   0,   0,
           0,   315, 317, 1,   0,   0,   0,   316, 314, 1,   0,   0,   0,   317, 318, 3,   40,  20,  0,   318, 39,  1,   0,   0,   0,   319,
           321, 5,   12,  0,   0,   320, 319, 1,   0,   0,   0,   320, 321, 1,   0,   0,   0,   321, 322, 1,   0,   0,   0,   322, 324, 3,
           50,  25,  0,   323, 325, 3,   54,  27,  0,   324, 323, 1,   0,   0,   0,   324, 325, 1,   0,   0,   0,   325, 327, 1,   0,   0,
           0,   326, 320, 1,   0,   0,   0,   326, 327, 1,   0,   0,   0,   327, 41,  1,   0,   0,   0,   328, 333, 3,   44,  22,  0,   329,
           330, 5,   2,   0,   0,   330, 332, 3,   44,  22,  0,   331, 329, 1,   0,   0,   0,   332, 335, 1,   0,   0,   0,   333, 331, 1,
           0,   0,   0,   333, 334, 1,   0,   0,   0,   334, 43,  1,   0,   0,   0,   335, 333, 1,   0,   0,   0,   336, 341, 3,   58,  29,
           0,   337, 338, 5,   5,   0,   0,   338, 340, 3,   58,  29,  0,   339, 337, 1,   0,   0,   0,   340, 343, 1,   0,   0,   0,   341,
           339, 1,   0,   0,   0,   341, 342, 1,   0,   0,   0,   342, 45,  1,   0,   0,   0,   343, 341, 1,   0,   0,   0,   344, 352, 3,
           64,  32,  0,   345, 347, 5,   12,  0,   0,   346, 345, 1,   0,   0,   0,   346, 347, 1,   0,   0,   0,   347, 350, 1,   0,   0,
           0,   348, 351, 3,   58,  29,  0,   349, 351, 3,   54,  27,  0,   350, 348, 1,   0,   0,   0,   350, 349, 1,   0,   0,   0,   351,
           353, 1,   0,   0,   0,   352, 346, 1,   0,   0,   0,   352, 353, 1,   0,   0,   0,   353, 47,  1,   0,   0,   0,   354, 358, 3,
           50,  25,  0,   355, 356, 4,   24,  1,   0,   356, 358, 3,   134, 67,  0,   357, 354, 1,   0,   0,   0,   357, 355, 1,   0,   0,
           0,   358, 49,  1,   0,   0,   0,   359, 366, 5,   135, 0,   0,   360, 366, 3,   52,  26,  0,   361, 362, 4,   25,  2,   0,   362,
           366, 3,   136, 68,  0,   363, 364, 4,   25,  3,   0,   364, 366, 3,   138, 69,  0,   365, 359, 1,   0,   0,   0,   365, 360, 1,
           0,   0,   0,   365, 361, 1,   0,   0,   0,   365, 363, 1,   0,   0,   0,   366, 51,  1,   0,   0,   0,   367, 368, 5,   8,   0,
           0,   368, 53,  1,   0,   0,   0,   369, 370, 5,   3,   0,   0,   370, 371, 3,   56,  28,  0,   371, 372, 5,   4,   0,   0,   372,
           55,  1,   0,   0,   0,   373, 378, 3,   58,  29,  0,   374, 375, 5,   2,   0,   0,   375, 377, 3,   58,  29,  0,   376, 374, 1,
           0,   0,   0,   377, 380, 1,   0,   0,   0,   378, 376, 1,   0,   0,   0,   378, 379, 1,   0,   0,   0,   379, 57,  1,   0,   0,
           0,   380, 378, 1,   0,   0,   0,   381, 382, 3,   48,  24,  0,   382, 383, 3,   60,  30,  0,   383, 59,  1,   0,   0,   0,   384,
           385, 5,   112, 0,   0,   385, 387, 3,   48,  24,  0,   386, 384, 1,   0,   0,   0,   387, 388, 1,   0,   0,   0,   388, 386, 1,
           0,   0,   0,   388, 389, 1,   0,   0,   0,   389, 392, 1,   0,   0,   0,   390, 392, 1,   0,   0,   0,   391, 386, 1,   0,   0,
           0,   391, 390, 1,   0,   0,   0,   392, 61,  1,   0,   0,   0,   393, 398, 3,   46,  23,  0,   394, 395, 5,   2,   0,   0,   395,
           397, 3,   46,  23,  0,   396, 394, 1,   0,   0,   0,   397, 400, 1,   0,   0,   0,   398, 396, 1,   0,   0,   0,   398, 399, 1,
           0,   0,   0,   399, 63,  1,   0,   0,   0,   400, 398, 1,   0,   0,   0,   401, 402, 3,   66,  33,  0,   402, 65,  1,   0,   0,
           0,   403, 404, 6,   33,  -1,  0,   404, 405, 5,   50,  0,   0,   405, 416, 3,   66,  33,  5,   406, 407, 5,   27,  0,   0,   407,
           408, 5,   3,   0,   0,   408, 409, 3,   4,   2,   0,   409, 410, 5,   4,   0,   0,   410, 416, 1,   0,   0,   0,   411, 413, 3,
           116, 58,  0,   412, 414, 3,   114, 57,  0,   413, 412, 1,   0,   0,   0,   413, 414, 1,   0,   0,   0,   414, 416, 1,   0,   0,
           0,   415, 403, 1,   0,   0,   0,   415, 406, 1,   0,   0,   0,   415, 411, 1,   0,   0,   0,   416, 425, 1,   0,   0,   0,   417,
           418, 10,  2,   0,   0,   418, 419, 5,   10,  0,   0,   419, 424, 3,   66,  33,  3,   420, 421, 10,  1,   0,   0,   421, 422, 5,
           55,  0,   0,   422, 424, 3,   66,  33,  2,   423, 417, 1,   0,   0,   0,   423, 420, 1,   0,   0,   0,   424, 427, 1,   0,   0,
           0,   425, 423, 1,   0,   0,   0,   425, 426, 1,   0,   0,   0,   426, 67,  1,   0,   0,   0,   427, 425, 1,   0,   0,   0,   428,
           430, 3,   70,  35,  0,   429, 428, 1,   0,   0,   0,   429, 430, 1,   0,   0,   0,   430, 431, 1,   0,   0,   0,   431, 433, 3,
           74,  37,  0,   432, 434, 3,   76,  38,  0,   433, 432, 1,   0,   0,   0,   433, 434, 1,   0,   0,   0,   434, 69,  1,   0,   0,
           0,   435, 436, 5,   33,  0,   0,   436, 437, 5,   16,  0,   0,   437, 442, 3,   64,  32,  0,   438, 439, 5,   2,   0,   0,   439,
           441, 3,   64,  32,  0,   440, 438, 1,   0,   0,   0,   441, 444, 1,   0,   0,   0,   442, 440, 1,   0,   0,   0,   442, 443, 1,
           0,   0,   0,   443, 462, 1,   0,   0,   0,   444, 442, 1,   0,   0,   0,   445, 446, 5,   78,  0,   0,   446, 463, 5,   61,  0,
           0,   447, 448, 5,   78,  0,   0,   448, 463, 5,   18,  0,   0,   449, 450, 5,   34,  0,   0,   450, 451, 5,   63,  0,   0,   451,
           452, 5,   3,   0,   0,   452, 457, 3,   72,  36,  0,   453, 454, 5,   2,   0,   0,   454, 456, 3,   72,  36,  0,   455, 453, 1,
           0,   0,   0,   456, 459, 1,   0,   0,   0,   457, 455, 1,   0,   0,   0,   457, 458, 1,   0,   0,   0,   458, 460, 1,   0,   0,
           0,   459, 457, 1,   0,   0,   0,   460, 461, 5,   4,   0,   0,   461, 463, 1,   0,   0,   0,   462, 445, 1,   0,   0,   0,   462,
           447, 1,   0,   0,   0,   462, 449, 1,   0,   0,   0,   462, 463, 1,   0,   0,   0,   463, 480, 1,   0,   0,   0,   464, 465, 5,
           33,  0,   0,   465, 466, 5,   16,  0,   0,   466, 467, 5,   34,  0,   0,   467, 468, 5,   63,  0,   0,   468, 469, 5,   3,   0,
           0,   469, 474, 3,   72,  36,  0,   470, 471, 5,   2,   0,   0,   471, 473, 3,   72,  36,  0,   472, 470, 1,   0,   0,   0,   473,
           476, 1,   0,   0,   0,   474, 472, 1,   0,   0,   0,   474, 475, 1,   0,   0,   0,   475, 477, 1,   0,   0,   0,   476, 474, 1,
           0,   0,   0,   477, 478, 5,   4,   0,   0,   478, 480, 1,   0,   0,   0,   479, 435, 1,   0,   0,   0,   479, 464, 1,   0,   0,
           0,   480, 71,  1,   0,   0,   0,   481, 490, 5,   3,   0,   0,   482, 487, 3,   64,  32,  0,   483, 484, 5,   2,   0,   0,   484,
           486, 3,   64,  32,  0,   485, 483, 1,   0,   0,   0,   486, 489, 1,   0,   0,   0,   487, 485, 1,   0,   0,   0,   487, 488, 1,
           0,   0,   0,   488, 491, 1,   0,   0,   0,   489, 487, 1,   0,   0,   0,   490, 482, 1,   0,   0,   0,   490, 491, 1,   0,   0,
           0,   491, 492, 1,   0,   0,   0,   492, 495, 5,   4,   0,   0,   493, 495, 3,   64,  32,  0,   494, 481, 1,   0,   0,   0,   494,
           493, 1,   0,   0,   0,   495, 73,  1,   0,   0,   0,   496, 497, 5,   77,  0,   0,   497, 498, 3,   80,  40,  0,   498, 75,  1,
           0,   0,   0,   499, 500, 5,   94,  0,   0,   500, 501, 5,   3,   0,   0,   501, 502, 3,   78,  39,  0,   502, 503, 5,   4,   0,
           0,   503, 77,  1,   0,   0,   0,   504, 505, 3,   48,  24,  0,   505, 506, 5,   2,   0,   0,   506, 507, 5,   125, 0,   0,   507,
           508, 3,   96,  48,  0,   508, 79,  1,   0,   0,   0,   509, 513, 3,   82,  41,  0,   510, 513, 3,   84,  42,  0,   511, 513, 3,
           86,  43,  0,   512, 509, 1,   0,   0,   0,   512, 510, 1,   0,   0,   0,   512, 511, 1,   0,   0,   0,   513, 81,  1,   0,   0,
           0,   514, 515, 5,   79,  0,   0,   515, 519, 5,   3,   0,   0,   516, 517, 3,   98,  49,  0,   517, 518, 5,   2,   0,   0,   518,
           520, 1,   0,   0,   0,   519, 516, 1,   0,   0,   0,   519, 520, 1,   0,   0,   0,   520, 521, 1,   0,   0,   0,   521, 522, 3,
           92,  46,  0,   522, 523, 5,   4,   0,   0,   523, 537, 1,   0,   0,   0,   524, 525, 5,   80,  0,   0,   525, 529, 5,   3,   0,
           0,   526, 527, 3,   98,  49,  0,   527, 528, 5,   2,   0,   0,   528, 530, 1,   0,   0,   0,   529, 526, 1,   0,   0,   0,   529,
           530, 1,   0,   0,   0,   530, 531, 1,   0,   0,   0,   531, 532, 3,   92,  46,  0,   532, 533, 5,   2,   0,   0,   533, 534, 3,
           94,  47,  0,   534, 535, 5,   4,   0,   0,   535, 537, 1,   0,   0,   0,   536, 514, 1,   0,   0,   0,   536, 524, 1,   0,   0,
           0,   537, 83,  1,   0,   0,   0,   538, 539, 5,   79,  0,   0,   539, 540, 5,   3,   0,   0,   540, 541, 5,   125, 0,   0,   541,
           542, 5,   4,   0,   0,   542, 85,  1,   0,   0,   0,   543, 544, 5,   81,  0,   0,   544, 545, 5,   3,   0,   0,   545, 548, 3,
           88,  44,  0,   546, 547, 5,   2,   0,   0,   547, 549, 3,   90,  45,  0,   548, 546, 1,   0,   0,   0,   548, 549, 1,   0,   0,
           0,   549, 550, 1,   0,   0,   0,   550, 551, 5,   4,   0,   0,   551, 87,  1,   0,   0,   0,   552, 553, 3,   64,  32,  0,   553,
           89,  1,   0,   0,   0,   554, 555, 5,   125, 0,   0,   555, 91,  1,   0,   0,   0,   556, 557, 5,   82,  0,   0,   557, 558, 5,
           125, 0,   0,   558, 559, 3,   96,  48,  0,   559, 93,  1,   0,   0,   0,   560, 561, 5,   83,  0,   0,   561, 562, 5,   16,  0,
           0,   562, 563, 5,   125, 0,   0,   563, 564, 3,   96,  48,  0,   564, 95,  1,   0,   0,   0,   565, 566, 7,   0,   0,   0,   566,
           97,  1,   0,   0,   0,   567, 568, 5,   135, 0,   0,   568, 99,  1,   0,   0,   0,   569, 570, 7,   1,   0,   0,   570, 101, 1,
           0,   0,   0,   571, 572, 5,   40,  0,   0,   572, 577, 3,   104, 52,  0,   573, 574, 5,   2,   0,   0,   574, 576, 3,   104, 52,
           0,   575, 573, 1,   0,   0,   0,   576, 579, 1,   0,   0,   0,   577, 575, 1,   0,   0,   0,   577, 578, 1,   0,   0,   0,   578,
           103, 1,   0,   0,   0,   579, 577, 1,   0,   0,   0,   580, 581, 3,   48,  24,  0,   581, 105, 1,   0,   0,   0,   582, 584, 5,
           50,  0,   0,   583, 582, 1,   0,   0,   0,   583, 584, 1,   0,   0,   0,   584, 585, 1,   0,   0,   0,   585, 586, 5,   51,  0,
           0,   586, 107, 1,   0,   0,   0,   587, 588, 5,   135, 0,   0,   588, 109, 1,   0,   0,   0,   589, 590, 5,   99,  0,   0,   590,
           111, 1,   0,   0,   0,   591, 593, 3,   64,  32,  0,   592, 594, 7,   2,   0,   0,   593, 592, 1,   0,   0,   0,   593, 594, 1,
           0,   0,   0,   594, 597, 1,   0,   0,   0,   595, 596, 5,   52,  0,   0,   596, 598, 7,   3,   0,   0,   597, 595, 1,   0,   0,
           0,   597, 598, 1,   0,   0,   0,   598, 113, 1,   0,   0,   0,   599, 601, 5,   50,  0,   0,   600, 599, 1,   0,   0,   0,   600,
           601, 1,   0,   0,   0,   601, 602, 1,   0,   0,   0,   602, 603, 5,   15,  0,   0,   603, 604, 3,   116, 58,  0,   604, 605, 5,
           10,  0,   0,   605, 606, 3,   116, 58,  0,   606, 679, 1,   0,   0,   0,   607, 609, 5,   50,  0,   0,   608, 607, 1,   0,   0,
           0,   608, 609, 1,   0,   0,   0,   609, 610, 1,   0,   0,   0,   610, 611, 5,   37,  0,   0,   611, 612, 5,   3,   0,   0,   612,
           617, 3,   64,  32,  0,   613, 614, 5,   2,   0,   0,   614, 616, 3,   64,  32,  0,   615, 613, 1,   0,   0,   0,   616, 619, 1,
           0,   0,   0,   617, 615, 1,   0,   0,   0,   617, 618, 1,   0,   0,   0,   618, 620, 1,   0,   0,   0,   619, 617, 1,   0,   0,
           0,   620, 621, 5,   4,   0,   0,   621, 679, 1,   0,   0,   0,   622, 624, 5,   50,  0,   0,   623, 622, 1,   0,   0,   0,   623,
           624, 1,   0,   0,   0,   624, 625, 1,   0,   0,   0,   625, 626, 5,   37,  0,   0,   626, 627, 5,   3,   0,   0,   627, 628, 3,
           4,   2,   0,   628, 629, 5,   4,   0,   0,   629, 679, 1,   0,   0,   0,   630, 632, 5,   50,  0,   0,   631, 630, 1,   0,   0,
           0,   631, 632, 1,   0,   0,   0,   632, 633, 1,   0,   0,   0,   633, 634, 5,   60,  0,   0,   634, 679, 3,   116, 58,  0,   635,
           637, 5,   50,  0,   0,   636, 635, 1,   0,   0,   0,   636, 637, 1,   0,   0,   0,   637, 638, 1,   0,   0,   0,   638, 639, 5,
           45,  0,   0,   639, 653, 7,   4,   0,   0,   640, 641, 5,   3,   0,   0,   641, 654, 5,   4,   0,   0,   642, 643, 5,   3,   0,
           0,   643, 648, 3,   64,  32,  0,   644, 645, 5,   2,   0,   0,   645, 647, 3,   64,  32,  0,   646, 644, 1,   0,   0,   0,   647,
           650, 1,   0,   0,   0,   648, 646, 1,   0,   0,   0,   648, 649, 1,   0,   0,   0,   649, 651, 1,   0,   0,   0,   650, 648, 1,
           0,   0,   0,   651, 652, 5,   4,   0,   0,   652, 654, 1,   0,   0,   0,   653, 640, 1,   0,   0,   0,   653, 642, 1,   0,   0,
           0,   654, 679, 1,   0,   0,   0,   655, 657, 5,   50,  0,   0,   656, 655, 1,   0,   0,   0,   656, 657, 1,   0,   0,   0,   657,
           658, 1,   0,   0,   0,   658, 659, 5,   45,  0,   0,   659, 662, 3,   116, 58,  0,   660, 661, 5,   26,  0,   0,   661, 663, 5,
           121, 0,   0,   662, 660, 1,   0,   0,   0,   662, 663, 1,   0,   0,   0,   663, 679, 1,   0,   0,   0,   664, 665, 5,   41,  0,
           0,   665, 679, 3,   106, 53,  0,   666, 668, 5,   41,  0,   0,   667, 669, 5,   50,  0,   0,   668, 667, 1,   0,   0,   0,   668,
           669, 1,   0,   0,   0,   669, 670, 1,   0,   0,   0,   670, 679, 7,   5,   0,   0,   671, 673, 5,   41,  0,   0,   672, 674, 5,
           50,  0,   0,   673, 672, 1,   0,   0,   0,   673, 674, 1,   0,   0,   0,   674, 675, 1,   0,   0,   0,   675, 676, 5,   21,  0,
           0,   676, 677, 5,   31,  0,   0,   677, 679, 3,   116, 58,  0,   678, 600, 1,   0,   0,   0,   678, 608, 1,   0,   0,   0,   678,
           623, 1,   0,   0,   0,   678, 631, 1,   0,   0,   0,   678, 636, 1,   0,   0,   0,   678, 656, 1,   0,   0,   0,   678, 664, 1,
           0,   0,   0,   678, 666, 1,   0,   0,   0,   678, 671, 1,   0,   0,   0,   679, 115, 1,   0,   0,   0,   680, 681, 6,   58,  -1,
           0,   681, 685, 3,   124, 62,  0,   682, 683, 7,   6,   0,   0,   683, 685, 3,   116, 58,  7,   684, 680, 1,   0,   0,   0,   684,
           682, 1,   0,   0,   0,   685, 707, 1,   0,   0,   0,   686, 687, 10,  6,   0,   0,   687, 688, 7,   7,   0,   0,   688, 706, 3,
           116, 58,  7,   689, 690, 10,  5,   0,   0,   690, 691, 7,   8,   0,   0,   691, 706, 3,   116, 58,  6,   692, 693, 10,  4,   0,
           0,   693, 694, 5,   117, 0,   0,   694, 706, 3,   116, 58,  5,   695, 696, 10,  3,   0,   0,   696, 697, 5,   120, 0,   0,   697,
           706, 3,   116, 58,  4,   698, 699, 10,  2,   0,   0,   699, 700, 5,   118, 0,   0,   700, 706, 3,   116, 58,  3,   701, 702, 10,
           1,   0,   0,   702, 703, 3,   118, 59,  0,   703, 704, 3,   116, 58,  2,   704, 706, 1,   0,   0,   0,   705, 686, 1,   0,   0,
           0,   705, 689, 1,   0,   0,   0,   705, 692, 1,   0,   0,   0,   705, 695, 1,   0,   0,   0,   705, 698, 1,   0,   0,   0,   705,
           701, 1,   0,   0,   0,   706, 709, 1,   0,   0,   0,   707, 705, 1,   0,   0,   0,   707, 708, 1,   0,   0,   0,   708, 117, 1,
           0,   0,   0,   709, 707, 1,   0,   0,   0,   710, 711, 7,   9,   0,   0,   711, 119, 1,   0,   0,   0,   712, 713, 5,   6,   0,
           0,   713, 720, 3,   122, 61,  0,   714, 716, 5,   2,   0,   0,   715, 714, 1,   0,   0,   0,   715, 716, 1,   0,   0,   0,   716,
           717, 1,   0,   0,   0,   717, 719, 3,   122, 61,  0,   718, 715, 1,   0,   0,   0,   719, 722, 1,   0,   0,   0,   720, 718, 1,
           0,   0,   0,   720, 721, 1,   0,   0,   0,   721, 723, 1,   0,   0,   0,   722, 720, 1,   0,   0,   0,   723, 724, 5,   7,   0,
           0,   724, 121, 1,   0,   0,   0,   725, 739, 3,   48,  24,  0,   726, 727, 3,   48,  24,  0,   727, 728, 5,   3,   0,   0,   728,
           733, 3,   124, 62,  0,   729, 730, 5,   2,   0,   0,   730, 732, 3,   124, 62,  0,   731, 729, 1,   0,   0,   0,   732, 735, 1,
           0,   0,   0,   733, 731, 1,   0,   0,   0,   733, 734, 1,   0,   0,   0,   734, 736, 1,   0,   0,   0,   735, 733, 1,   0,   0,
           0,   736, 737, 5,   4,   0,   0,   737, 739, 1,   0,   0,   0,   738, 725, 1,   0,   0,   0,   738, 726, 1,   0,   0,   0,   739,
           123, 1,   0,   0,   0,   740, 741, 6,   62,  -1,  0,   741, 781, 5,   113, 0,   0,   742, 743, 3,   126, 63,  0,   743, 744, 5,
           5,   0,   0,   744, 745, 5,   113, 0,   0,   745, 781, 1,   0,   0,   0,   746, 747, 5,   3,   0,   0,   747, 748, 3,   4,   2,
           0,   748, 749, 5,   4,   0,   0,   749, 781, 1,   0,   0,   0,   750, 751, 5,   3,   0,   0,   751, 754, 3,   46,  23,  0,   752,
           753, 5,   2,   0,   0,   753, 755, 3,   46,  23,  0,   754, 752, 1,   0,   0,   0,   755, 756, 1,   0,   0,   0,   756, 754, 1,
           0,   0,   0,   756, 757, 1,   0,   0,   0,   757, 758, 1,   0,   0,   0,   758, 759, 5,   4,   0,   0,   759, 781, 1,   0,   0,
           0,   760, 761, 3,   100, 50,  0,   761, 770, 5,   3,   0,   0,   762, 767, 3,   64,  32,  0,   763, 764, 5,   2,   0,   0,   764,
           766, 3,   64,  32,  0,   765, 763, 1,   0,   0,   0,   766, 769, 1,   0,   0,   0,   767, 765, 1,   0,   0,   0,   767, 768, 1,
           0,   0,   0,   768, 771, 1,   0,   0,   0,   769, 767, 1,   0,   0,   0,   770, 762, 1,   0,   0,   0,   770, 771, 1,   0,   0,
           0,   771, 772, 1,   0,   0,   0,   772, 773, 5,   4,   0,   0,   773, 781, 1,   0,   0,   0,   774, 775, 5,   3,   0,   0,   775,
           776, 3,   64,  32,  0,   776, 777, 5,   4,   0,   0,   777, 781, 1,   0,   0,   0,   778, 781, 3,   130, 65,  0,   779, 781, 3,
           48,  24,  0,   780, 740, 1,   0,   0,   0,   780, 742, 1,   0,   0,   0,   780, 746, 1,   0,   0,   0,   780, 750, 1,   0,   0,
           0,   780, 760, 1,   0,   0,   0,   780, 774, 1,   0,   0,   0,   780, 778, 1,   0,   0,   0,   780, 779, 1,   0,   0,   0,   781,
           787, 1,   0,   0,   0,   782, 783, 10,  7,   0,   0,   783, 784, 5,   5,   0,   0,   784, 786, 3,   48,  24,  0,   785, 782, 1,
           0,   0,   0,   786, 789, 1,   0,   0,   0,   787, 785, 1,   0,   0,   0,   787, 788, 1,   0,   0,   0,   788, 125, 1,   0,   0,
           0,   789, 787, 1,   0,   0,   0,   790, 795, 3,   48,  24,  0,   791, 792, 5,   5,   0,   0,   792, 794, 3,   48,  24,  0,   793,
           791, 1,   0,   0,   0,   794, 797, 1,   0,   0,   0,   795, 793, 1,   0,   0,   0,   795, 796, 1,   0,   0,   0,   796, 127, 1,
           0,   0,   0,   797, 795, 1,   0,   0,   0,   798, 800, 4,   64,  13,  0,   799, 801, 5,   112, 0,   0,   800, 799, 1,   0,   0,
           0,   800, 801, 1,   0,   0,   0,   801, 802, 1,   0,   0,   0,   802, 858, 5,   130, 0,   0,   803, 805, 4,   64,  14,  0,   804,
           806, 5,   112, 0,   0,   805, 804, 1,   0,   0,   0,   805, 806, 1,   0,   0,   0,   806, 807, 1,   0,   0,   0,   807, 858, 5,
           131, 0,   0,   808, 810, 4,   64,  15,  0,   809, 811, 5,   112, 0,   0,   810, 809, 1,   0,   0,   0,   810, 811, 1,   0,   0,
           0,   811, 812, 1,   0,   0,   0,   812, 858, 7,   10,  0,   0,   813, 815, 5,   112, 0,   0,   814, 813, 1,   0,   0,   0,   814,
           815, 1,   0,   0,   0,   815, 816, 1,   0,   0,   0,   816, 858, 5,   125, 0,   0,   817, 819, 5,   112, 0,   0,   818, 817, 1,
           0,   0,   0,   818, 819, 1,   0,   0,   0,   819, 820, 1,   0,   0,   0,   820, 858, 5,   122, 0,   0,   821, 823, 5,   112, 0,
           0,   822, 821, 1,   0,   0,   0,   822, 823, 1,   0,   0,   0,   823, 824, 1,   0,   0,   0,   824, 858, 5,   123, 0,   0,   825,
           827, 5,   112, 0,   0,   826, 825, 1,   0,   0,   0,   826, 827, 1,   0,   0,   0,   827, 828, 1,   0,   0,   0,   828, 858, 5,
           124, 0,   0,   829, 831, 5,   112, 0,   0,   830, 829, 1,   0,   0,   0,   830, 831, 1,   0,   0,   0,   831, 832, 1,   0,   0,
           0,   832, 858, 5,   128, 0,   0,   833, 835, 5,   112, 0,   0,   834, 833, 1,   0,   0,   0,   834, 835, 1,   0,   0,   0,   835,
           836, 1,   0,   0,   0,   836, 858, 5,   129, 0,   0,   837, 839, 5,   112, 0,   0,   838, 837, 1,   0,   0,   0,   838, 839, 1,
           0,   0,   0,   839, 840, 1,   0,   0,   0,   840, 858, 5,   126, 0,   0,   841, 843, 5,   112, 0,   0,   842, 841, 1,   0,   0,
           0,   842, 843, 1,   0,   0,   0,   843, 844, 1,   0,   0,   0,   844, 858, 5,   127, 0,   0,   845, 847, 5,   112, 0,   0,   846,
           845, 1,   0,   0,   0,   846, 847, 1,   0,   0,   0,   847, 848, 1,   0,   0,   0,   848, 858, 5,   133, 0,   0,   849, 851, 5,
           112, 0,   0,   850, 849, 1,   0,   0,   0,   850, 851, 1,   0,   0,   0,   851, 852, 1,   0,   0,   0,   852, 858, 5,   132, 0,
           0,   853, 855, 5,   112, 0,   0,   854, 853, 1,   0,   0,   0,   854, 855, 1,   0,   0,   0,   855, 856, 1,   0,   0,   0,   856,
           858, 5,   134, 0,   0,   857, 798, 1,   0,   0,   0,   857, 803, 1,   0,   0,   0,   857, 808, 1,   0,   0,   0,   857, 814, 1,
           0,   0,   0,   857, 818, 1,   0,   0,   0,   857, 822, 1,   0,   0,   0,   857, 826, 1,   0,   0,   0,   857, 830, 1,   0,   0,
           0,   857, 834, 1,   0,   0,   0,   857, 838, 1,   0,   0,   0,   857, 842, 1,   0,   0,   0,   857, 846, 1,   0,   0,   0,   857,
           850, 1,   0,   0,   0,   857, 854, 1,   0,   0,   0,   858, 129, 1,   0,   0,   0,   859, 871, 5,   51,  0,   0,   860, 861, 3,
           48,  24,  0,   861, 862, 5,   121, 0,   0,   862, 871, 1,   0,   0,   0,   863, 871, 3,   128, 64,  0,   864, 871, 3,   132, 66,
           0,   865, 867, 5,   121, 0,   0,   866, 865, 1,   0,   0,   0,   867, 868, 1,   0,   0,   0,   868, 866, 1,   0,   0,   0,   868,
           869, 1,   0,   0,   0,   869, 871, 1,   0,   0,   0,   870, 859, 1,   0,   0,   0,   870, 860, 1,   0,   0,   0,   870, 863, 1,
           0,   0,   0,   870, 864, 1,   0,   0,   0,   870, 866, 1,   0,   0,   0,   871, 131, 1,   0,   0,   0,   872, 873, 7,   11,  0,
           0,   873, 133, 1,   0,   0,   0,   874, 875, 7,   12,  0,   0,   875, 135, 1,   0,   0,   0,   876, 877, 7,   13,  0,   0,   877,
           137, 1,   0,   0,   0,   878, 879, 7,   14,  0,   0,   879, 139, 1,   0,   0,   0,   105, 144, 161, 164, 169, 171, 175, 185, 197,
           202, 205, 208, 211, 219, 226, 233, 240, 243, 263, 272, 275, 284, 288, 291, 297, 314, 320, 324, 326, 333, 341, 346, 350, 352, 357,
           365, 378, 388, 391, 398, 413, 415, 423, 425, 429, 433, 442, 457, 462, 474, 479, 487, 490, 494, 512, 519, 529, 536, 548, 577, 583,
           593, 597, 600, 608, 617, 623, 631, 636, 648, 653, 656, 662, 668, 673, 678, 684, 705, 707, 715, 720, 733, 738, 756, 767, 770, 780,
           787, 795, 800, 805, 810, 814, 818, 822, 826, 830, 834, 838, 842, 846, 850, 854, 857, 868, 870};
    staticData->serializedATN
        = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

    antlr4::atn::ATNDeserializer deserializer;
    staticData->atn = deserializer.deserialize(staticData->serializedATN);

    const size_t count = staticData->atn->getNumberOfDecisions();
    staticData->decisionToDFA.reserve(count);
    for (size_t i = 0; i < count; i++)
    {
        staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
    }
    nebulasqlParserStaticData = std::move(staticData);
}

}

NebulaSQLParser::NebulaSQLParser(TokenStream* input) : NebulaSQLParser(input, antlr4::atn::ParserATNSimulatorOptions())
{
}

NebulaSQLParser::NebulaSQLParser(TokenStream* input, const antlr4::atn::ParserATNSimulatorOptions& options) : Parser(input)
{
    NebulaSQLParser::initialize();
    _interpreter = new atn::ParserATNSimulator(
        this,
        *nebulasqlParserStaticData->atn,
        nebulasqlParserStaticData->decisionToDFA,
        nebulasqlParserStaticData->sharedContextCache,
        options);
}

NebulaSQLParser::~NebulaSQLParser()
{
    delete _interpreter;
}

const atn::ATN& NebulaSQLParser::getATN() const
{
    return *nebulasqlParserStaticData->atn;
}

std::string NebulaSQLParser::getGrammarFileName() const
{
    return "NebulaSQL.g4";
}

const std::vector<std::string>& NebulaSQLParser::getRuleNames() const
{
    return nebulasqlParserStaticData->ruleNames;
}

const dfa::Vocabulary& NebulaSQLParser::getVocabulary() const
{
    return nebulasqlParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NebulaSQLParser::getSerializedATN() const
{
    return nebulasqlParserStaticData->serializedATN;
}


//----------------- SingleStatementContext ------------------------------------------------------------------

NebulaSQLParser::SingleStatementContext::SingleStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StatementContext* NebulaSQLParser::SingleStatementContext::statement()
{
    return getRuleContext<NebulaSQLParser::StatementContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SingleStatementContext::EOF()
{
    return getToken(NebulaSQLParser::EOF, 0);
}


size_t NebulaSQLParser::SingleStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSingleStatement;
}

void NebulaSQLParser::SingleStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSingleStatement(this);
}

void NebulaSQLParser::SingleStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSingleStatement(this);
}

NebulaSQLParser::SingleStatementContext* NebulaSQLParser::singleStatement()
{
    SingleStatementContext* _localctx = _tracker.createInstance<SingleStatementContext>(_ctx, getState());
    enterRule(_localctx, 0, NebulaSQLParser::RuleSingleStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(140);
        statement();
        setState(144);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__0)
        {
            setState(141);
            match(NebulaSQLParser::T__0);
            setState(146);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
        setState(147);
        match(NebulaSQLParser::EOF);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NebulaSQLParser::StatementContext::StatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::QueryContext* NebulaSQLParser::StatementContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}


size_t NebulaSQLParser::StatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStatement;
}

void NebulaSQLParser::StatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStatement(this);
}

void NebulaSQLParser::StatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStatement(this);
}

NebulaSQLParser::StatementContext* NebulaSQLParser::statement()
{
    StatementContext* _localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
    enterRule(_localctx, 2, NebulaSQLParser::RuleStatement);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(149);
        query();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext::QueryContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::QueryContext::queryTerm()
{
    return getRuleContext<NebulaSQLParser::QueryTermContext>(0);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::QueryContext::queryOrganization()
{
    return getRuleContext<NebulaSQLParser::QueryOrganizationContext>(0);
}


size_t NebulaSQLParser::QueryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuery;
}

void NebulaSQLParser::QueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuery(this);
}

void NebulaSQLParser::QueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuery(this);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::query()
{
    QueryContext* _localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
    enterRule(_localctx, 4, NebulaSQLParser::RuleQuery);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(151);
        queryTerm(0);
        setState(152);
        queryOrganization();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryOrganizationContext ------------------------------------------------------------------

NebulaSQLParser::QueryOrganizationContext::QueryOrganizationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ORDER()
{
    return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::OFFSET()
{
    return getToken(NebulaSQLParser::OFFSET, 0);
}

std::vector<NebulaSQLParser::SortItemContext*> NebulaSQLParser::QueryOrganizationContext::sortItem()
{
    return getRuleContexts<NebulaSQLParser::SortItemContext>();
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::QueryOrganizationContext::sortItem(size_t i)
{
    return getRuleContext<NebulaSQLParser::SortItemContext>(i);
}

std::vector<tree::TerminalNode*> NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE()
{
    return getTokens(NebulaSQLParser::INTEGER_VALUE);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::INTEGER_VALUE(size_t i)
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, i);
}

tree::TerminalNode* NebulaSQLParser::QueryOrganizationContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}


size_t NebulaSQLParser::QueryOrganizationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryOrganization;
}

void NebulaSQLParser::QueryOrganizationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQueryOrganization(this);
}

void NebulaSQLParser::QueryOrganizationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQueryOrganization(this);
}

NebulaSQLParser::QueryOrganizationContext* NebulaSQLParser::queryOrganization()
{
    QueryOrganizationContext* _localctx = _tracker.createInstance<QueryOrganizationContext>(_ctx, getState());
    enterRule(_localctx, 6, NebulaSQLParser::RuleQueryOrganization);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(164);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ORDER)
        {
            setState(154);
            match(NebulaSQLParser::ORDER);
            setState(155);
            match(NebulaSQLParser::BY);
            setState(156);
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext = sortItem();
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->order.push_back(
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext);
            setState(161);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == NebulaSQLParser::T__1)
            {
                setState(157);
                match(NebulaSQLParser::T__1);
                setState(158);
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext = sortItem();
                antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->order.push_back(
                    antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->sortItemContext);
                setState(163);
                _errHandler->sync(this);
                _la = _input->LA(1);
            }
        }
        setState(171);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::LIMIT)
        {
            setState(166);
            match(NebulaSQLParser::LIMIT);
            setState(169);
            _errHandler->sync(this);
            switch (_input->LA(1))
            {
                case NebulaSQLParser::ALL: {
                    setState(167);
                    match(NebulaSQLParser::ALL);
                    break;
                }

                case NebulaSQLParser::INTEGER_VALUE: {
                    setState(168);
                    antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->limit = match(NebulaSQLParser::INTEGER_VALUE);
                    break;
                }

                default:
                    throw NoViableAltException(this);
            }
        }
        setState(175);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::OFFSET)
        {
            setState(173);
            match(NebulaSQLParser::OFFSET);
            setState(174);
            antlrcpp::downCast<QueryOrganizationContext*>(_localctx)->offset = match(NebulaSQLParser::INTEGER_VALUE);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QueryTermContext ------------------------------------------------------------------

NebulaSQLParser::QueryTermContext::QueryTermContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::QueryTermContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryTerm;
}

void NebulaSQLParser::QueryTermContext::copyFrom(QueryTermContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::PrimaryQueryContext::queryPrimary()
{
    return getRuleContext<NebulaSQLParser::QueryPrimaryContext>(0);
}

NebulaSQLParser::PrimaryQueryContext::PrimaryQueryContext(QueryTermContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::PrimaryQueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPrimaryQuery(this);
}
void NebulaSQLParser::PrimaryQueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPrimaryQuery(this);
}
//----------------- SetOperationContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::QueryTermContext*> NebulaSQLParser::SetOperationContext::queryTerm()
{
    return getRuleContexts<NebulaSQLParser::QueryTermContext>();
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::SetOperationContext::queryTerm(size_t i)
{
    return getRuleContext<NebulaSQLParser::QueryTermContext>(i);
}

tree::TerminalNode* NebulaSQLParser::SetOperationContext::UNION()
{
    return getToken(NebulaSQLParser::UNION, 0);
}

NebulaSQLParser::SetOperationContext::SetOperationContext(QueryTermContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SetOperationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSetOperation(this);
}
void NebulaSQLParser::SetOperationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSetOperation(this);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm()
{
    return queryTerm(0);
}

NebulaSQLParser::QueryTermContext* NebulaSQLParser::queryTerm(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::QueryTermContext* _localctx = _tracker.createInstance<QueryTermContext>(_ctx, parentState);
    NebulaSQLParser::QueryTermContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 8;
    enterRecursionRule(_localctx, 8, NebulaSQLParser::RuleQueryTerm, precedence);


#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        _localctx = _tracker.createInstance<PrimaryQueryContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(178);
        queryPrimary();
        _ctx->stop = _input->LT(-1);
        setState(185);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                auto newContext
                    = _tracker.createInstance<SetOperationContext>(_tracker.createInstance<QueryTermContext>(parentContext, parentState));
                _localctx = newContext;
                newContext->left = previousContext;
                pushNewRecursionContext(newContext, startState, RuleQueryTerm);
                setState(180);

                if (!(precpred(_ctx, 1)))
                    throw FailedPredicateException(this, "precpred(_ctx, 1)");
                setState(181);
                antlrcpp::downCast<SetOperationContext*>(_localctx)->setoperator = match(NebulaSQLParser::UNION);
                setState(182);
                antlrcpp::downCast<SetOperationContext*>(_localctx)->right = queryTerm(2);
            }
            setState(187);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::QueryPrimaryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQueryPrimary;
}

void NebulaSQLParser::QueryPrimaryContext::copyFrom(QueryPrimaryContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryContext::SubqueryContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SubqueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubquery(this);
}
void NebulaSQLParser::SubqueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubquery(this);
}
//----------------- QueryPrimaryDefaultContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::QueryPrimaryDefaultContext::querySpecification()
{
    return getRuleContext<NebulaSQLParser::QuerySpecificationContext>(0);
}

NebulaSQLParser::QueryPrimaryDefaultContext::QueryPrimaryDefaultContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::QueryPrimaryDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQueryPrimaryDefault(this);
}
void NebulaSQLParser::QueryPrimaryDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQueryPrimaryDefault(this);
}
//----------------- InlineTableDefault1Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault1Context::inlineTable()
{
    return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault1Context::InlineTableDefault1Context(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::InlineTableDefault1Context::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTableDefault1(this);
}
void NebulaSQLParser::InlineTableDefault1Context::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTableDefault1(this);
}
//----------------- FromStmtContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext* NebulaSQLParser::FromStmtContext::fromStatement()
{
    return getRuleContext<NebulaSQLParser::FromStatementContext>(0);
}

NebulaSQLParser::FromStmtContext::FromStmtContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FromStmtContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStmt(this);
}
void NebulaSQLParser::FromStmtContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStmt(this);
}
//----------------- TableContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TableContext::TABLE()
{
    return getToken(NebulaSQLParser::TABLE, 0);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableContext::multipartIdentifier()
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableContext::TableContext(QueryPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTable(this);
}
void NebulaSQLParser::TableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTable(this);
}
NebulaSQLParser::QueryPrimaryContext* NebulaSQLParser::queryPrimary()
{
    QueryPrimaryContext* _localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 10, NebulaSQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(197);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::SELECT: {
                _localctx = _tracker.createInstance<NebulaSQLParser::QueryPrimaryDefaultContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(188);
                querySpecification();
                break;
            }

            case NebulaSQLParser::FROM: {
                _localctx = _tracker.createInstance<NebulaSQLParser::FromStmtContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(189);
                fromStatement();
                break;
            }

            case NebulaSQLParser::TABLE: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(190);
                match(NebulaSQLParser::TABLE);
                setState(191);
                multipartIdentifier();
                break;
            }

            case NebulaSQLParser::VALUES: {
                _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault1Context>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(192);
                inlineTable();
                break;
            }

            case NebulaSQLParser::T__2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SubqueryContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(193);
                match(NebulaSQLParser::T__2);
                setState(194);
                query();
                setState(195);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

NebulaSQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::QuerySpecificationContext::selectClause()
{
    return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::QuerySpecificationContext::fromClause()
{
    return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::QuerySpecificationContext::whereClause()
{
    return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::QuerySpecificationContext::windowedAggregationClause()
{
    return getRuleContext<NebulaSQLParser::WindowedAggregationClauseContext>(0);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::QuerySpecificationContext::havingClause()
{
    return getRuleContext<NebulaSQLParser::HavingClauseContext>(0);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::QuerySpecificationContext::sinkClause()
{
    return getRuleContext<NebulaSQLParser::SinkClauseContext>(0);
}


size_t NebulaSQLParser::QuerySpecificationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuerySpecification;
}

void NebulaSQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuerySpecification(this);
}

void NebulaSQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuerySpecification(this);
}

NebulaSQLParser::QuerySpecificationContext* NebulaSQLParser::querySpecification()
{
    QuerySpecificationContext* _localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 12, NebulaSQLParser::RuleQuerySpecification);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(199);
        selectClause();
        setState(200);
        fromClause();
        setState(202);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx))
        {
            case 1: {
                setState(201);
                whereClause();
                break;
            }

            default:
                break;
        }
        setState(205);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx))
        {
            case 1: {
                setState(204);
                windowedAggregationClause();
                break;
            }

            default:
                break;
        }
        setState(208);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx))
        {
            case 1: {
                setState(207);
                havingClause();
                break;
            }

            default:
                break;
        }
        setState(211);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx))
        {
            case 1: {
                setState(210);
                sinkClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

NebulaSQLParser::FromClauseContext::FromClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FromClauseContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

std::vector<NebulaSQLParser::RelationContext*> NebulaSQLParser::FromClauseContext::relation()
{
    return getRuleContexts<NebulaSQLParser::RelationContext>();
}

NebulaSQLParser::RelationContext* NebulaSQLParser::FromClauseContext::relation(size_t i)
{
    return getRuleContext<NebulaSQLParser::RelationContext>(i);
}


size_t NebulaSQLParser::FromClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromClause;
}

void NebulaSQLParser::FromClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromClause(this);
}

void NebulaSQLParser::FromClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromClause(this);
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::fromClause()
{
    FromClauseContext* _localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
    enterRule(_localctx, 14, NebulaSQLParser::RuleFromClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(213);
        match(NebulaSQLParser::FROM);
        setState(214);
        relation();
        setState(219);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(215);
                match(NebulaSQLParser::T__1);
                setState(216);
                relation();
            }
            setState(221);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- RelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext::RelationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::RelationContext::relationPrimary()
{
    return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

std::vector<NebulaSQLParser::JoinRelationContext*> NebulaSQLParser::RelationContext::joinRelation()
{
    return getRuleContexts<NebulaSQLParser::JoinRelationContext>();
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::RelationContext::joinRelation(size_t i)
{
    return getRuleContext<NebulaSQLParser::JoinRelationContext>(i);
}


size_t NebulaSQLParser::RelationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleRelation;
}

void NebulaSQLParser::RelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRelation(this);
}

void NebulaSQLParser::RelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRelation(this);
}

NebulaSQLParser::RelationContext* NebulaSQLParser::relation()
{
    RelationContext* _localctx = _tracker.createInstance<RelationContext>(_ctx, getState());
    enterRule(_localctx, 16, NebulaSQLParser::RuleRelation);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(222);
        relationPrimary();
        setState(226);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(223);
                joinRelation();
            }
            setState(228);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinRelationContext ------------------------------------------------------------------

NebulaSQLParser::JoinRelationContext::JoinRelationContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::JOIN()
{
    return getToken(NebulaSQLParser::JOIN, 0);
}

NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::JoinRelationContext::relationPrimary()
{
    return getRuleContext<NebulaSQLParser::RelationPrimaryContext>(0);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::JoinRelationContext::joinType()
{
    return getRuleContext<NebulaSQLParser::JoinTypeContext>(0);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::JoinRelationContext::joinCriteria()
{
    return getRuleContext<NebulaSQLParser::JoinCriteriaContext>(0);
}

tree::TerminalNode* NebulaSQLParser::JoinRelationContext::NATURAL()
{
    return getToken(NebulaSQLParser::NATURAL, 0);
}


size_t NebulaSQLParser::JoinRelationContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinRelation;
}

void NebulaSQLParser::JoinRelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinRelation(this);
}

void NebulaSQLParser::JoinRelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinRelation(this);
}

NebulaSQLParser::JoinRelationContext* NebulaSQLParser::joinRelation()
{
    JoinRelationContext* _localctx = _tracker.createInstance<JoinRelationContext>(_ctx, getState());
    enterRule(_localctx, 18, NebulaSQLParser::RuleJoinRelation);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(240);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::INNER:
            case NebulaSQLParser::JOIN: {
                enterOuterAlt(_localctx, 1);
                setState(229);
                joinType();
                setState(230);
                match(NebulaSQLParser::JOIN);
                setState(231);
                antlrcpp::downCast<JoinRelationContext*>(_localctx)->right = relationPrimary();
                setState(233);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx))
                {
                    case 1: {
                        setState(232);
                        joinCriteria();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case NebulaSQLParser::NATURAL: {
                enterOuterAlt(_localctx, 2);
                setState(235);
                match(NebulaSQLParser::NATURAL);
                setState(236);
                joinType();
                setState(237);
                match(NebulaSQLParser::JOIN);
                setState(238);
                antlrcpp::downCast<JoinRelationContext*>(_localctx)->right = relationPrimary();
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinTypeContext ------------------------------------------------------------------

NebulaSQLParser::JoinTypeContext::JoinTypeContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinTypeContext::INNER()
{
    return getToken(NebulaSQLParser::INNER, 0);
}


size_t NebulaSQLParser::JoinTypeContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinType;
}

void NebulaSQLParser::JoinTypeContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinType(this);
}

void NebulaSQLParser::JoinTypeContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinType(this);
}

NebulaSQLParser::JoinTypeContext* NebulaSQLParser::joinType()
{
    JoinTypeContext* _localctx = _tracker.createInstance<JoinTypeContext>(_ctx, getState());
    enterRule(_localctx, 20, NebulaSQLParser::RuleJoinType);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(243);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::INNER)
        {
            setState(242);
            match(NebulaSQLParser::INNER);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- JoinCriteriaContext ------------------------------------------------------------------

NebulaSQLParser::JoinCriteriaContext::JoinCriteriaContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::JoinCriteriaContext::ON()
{
    return getToken(NebulaSQLParser::ON, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::JoinCriteriaContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::JoinCriteriaContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleJoinCriteria;
}

void NebulaSQLParser::JoinCriteriaContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterJoinCriteria(this);
}

void NebulaSQLParser::JoinCriteriaContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitJoinCriteria(this);
}

NebulaSQLParser::JoinCriteriaContext* NebulaSQLParser::joinCriteria()
{
    JoinCriteriaContext* _localctx = _tracker.createInstance<JoinCriteriaContext>(_ctx, getState());
    enterRule(_localctx, 22, NebulaSQLParser::RuleJoinCriteria);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(245);
        match(NebulaSQLParser::ON);
        setState(246);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- RelationPrimaryContext ------------------------------------------------------------------

NebulaSQLParser::RelationPrimaryContext::RelationPrimaryContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::RelationPrimaryContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleRelationPrimary;
}

void NebulaSQLParser::RelationPrimaryContext::copyFrom(RelationPrimaryContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TableValuedFunctionContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::TableValuedFunctionContext::functionTable()
{
    return getRuleContext<NebulaSQLParser::FunctionTableContext>(0);
}

NebulaSQLParser::TableValuedFunctionContext::TableValuedFunctionContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableValuedFunctionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableValuedFunction(this);
}
void NebulaSQLParser::TableValuedFunctionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableValuedFunction(this);
}
//----------------- InlineTableDefault2Context ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext* NebulaSQLParser::InlineTableDefault2Context::inlineTable()
{
    return getRuleContext<NebulaSQLParser::InlineTableContext>(0);
}

NebulaSQLParser::InlineTableDefault2Context::InlineTableDefault2Context(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::InlineTableDefault2Context::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTableDefault2(this);
}
void NebulaSQLParser::InlineTableDefault2Context::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTableDefault2(this);
}
//----------------- AliasedRelationContext ------------------------------------------------------------------

NebulaSQLParser::RelationContext* NebulaSQLParser::AliasedRelationContext::relation()
{
    return getRuleContext<NebulaSQLParser::RelationContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedRelationContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedRelationContext::AliasedRelationContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::AliasedRelationContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAliasedRelation(this);
}
void NebulaSQLParser::AliasedRelationContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAliasedRelation(this);
}
//----------------- AliasedQueryContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::AliasedQueryContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::AliasedQueryContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::AliasedQueryContext::AliasedQueryContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::AliasedQueryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAliasedQuery(this);
}
void NebulaSQLParser::AliasedQueryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAliasedQuery(this);
}
//----------------- TableNameContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::TableNameContext::multipartIdentifier()
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(0);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::TableNameContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::TableNameContext::TableNameContext(RelationPrimaryContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TableNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableName(this);
}
void NebulaSQLParser::TableNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableName(this);
}
NebulaSQLParser::RelationPrimaryContext* NebulaSQLParser::relationPrimary()
{
    RelationPrimaryContext* _localctx = _tracker.createInstance<RelationPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 24, NebulaSQLParser::RuleRelationPrimary);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(263);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableNameContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(248);
                multipartIdentifier();
                setState(249);
                tableAlias();
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::AliasedQueryContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(251);
                match(NebulaSQLParser::T__2);
                setState(252);
                query();
                setState(253);
                match(NebulaSQLParser::T__3);
                setState(254);
                tableAlias();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::AliasedRelationContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(256);
                match(NebulaSQLParser::T__2);
                setState(257);
                relation();
                setState(258);
                match(NebulaSQLParser::T__3);
                setState(259);
                tableAlias();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::InlineTableDefault2Context>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(261);
                inlineTable();
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TableValuedFunctionContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(262);
                functionTable();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionTableContext ------------------------------------------------------------------

NebulaSQLParser::FunctionTableContext::FunctionTableContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::FunctionTableContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::FunctionTableContext::errorCapturingIdentifier()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::FunctionTableContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionTableContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::FunctionTableContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFunctionTable;
}

void NebulaSQLParser::FunctionTableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionTable(this);
}

void NebulaSQLParser::FunctionTableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionTable(this);
}

NebulaSQLParser::FunctionTableContext* NebulaSQLParser::functionTable()
{
    FunctionTableContext* _localctx = _tracker.createInstance<FunctionTableContext>(_ctx, getState());
    enterRule(_localctx, 26, NebulaSQLParser::RuleFunctionTable);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(265);
        antlrcpp::downCast<FunctionTableContext*>(_localctx)->funcName = errorCapturingIdentifier();
        setState(266);
        match(NebulaSQLParser::T__2);
        setState(275);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx))
        {
            case 1: {
                setState(267);
                expression();
                setState(272);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(268);
                    match(NebulaSQLParser::T__1);
                    setState(269);
                    expression();
                    setState(274);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                break;
            }

            default:
                break;
        }
        setState(277);
        match(NebulaSQLParser::T__3);
        setState(278);
        tableAlias();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromStatementContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementContext::FromStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::FromClauseContext* NebulaSQLParser::FromStatementContext::fromClause()
{
    return getRuleContext<NebulaSQLParser::FromClauseContext>(0);
}

std::vector<NebulaSQLParser::FromStatementBodyContext*> NebulaSQLParser::FromStatementContext::fromStatementBody()
{
    return getRuleContexts<NebulaSQLParser::FromStatementBodyContext>();
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::FromStatementContext::fromStatementBody(size_t i)
{
    return getRuleContext<NebulaSQLParser::FromStatementBodyContext>(i);
}


size_t NebulaSQLParser::FromStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromStatement;
}

void NebulaSQLParser::FromStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStatement(this);
}

void NebulaSQLParser::FromStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStatement(this);
}

NebulaSQLParser::FromStatementContext* NebulaSQLParser::fromStatement()
{
    FromStatementContext* _localctx = _tracker.createInstance<FromStatementContext>(_ctx, getState());
    enterRule(_localctx, 28, NebulaSQLParser::RuleFromStatement);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(280);
        fromClause();
        setState(282);
        _errHandler->sync(this);
        alt = 1;
        do
        {
            switch (alt)
            {
                case 1: {
                    setState(281);
                    fromStatementBody();
                    break;
                }

                default:
                    throw NoViableAltException(this);
            }
            setState(284);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FromStatementBodyContext ------------------------------------------------------------------

NebulaSQLParser::FromStatementBodyContext::FromStatementBodyContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::FromStatementBodyContext::selectClause()
{
    return getRuleContext<NebulaSQLParser::SelectClauseContext>(0);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::FromStatementBodyContext::whereClause()
{
    return getRuleContext<NebulaSQLParser::WhereClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::FromStatementBodyContext::aggregationClause()
{
    return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}


size_t NebulaSQLParser::FromStatementBodyContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFromStatementBody;
}

void NebulaSQLParser::FromStatementBodyContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFromStatementBody(this);
}

void NebulaSQLParser::FromStatementBodyContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFromStatementBody(this);
}

NebulaSQLParser::FromStatementBodyContext* NebulaSQLParser::fromStatementBody()
{
    FromStatementBodyContext* _localctx = _tracker.createInstance<FromStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 30, NebulaSQLParser::RuleFromStatementBody);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(286);
        selectClause();
        setState(288);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx))
        {
            case 1: {
                setState(287);
                whereClause();
                break;
            }

            default:
                break;
        }
        setState(291);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx))
        {
            case 1: {
                setState(290);
                aggregationClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SelectClauseContext ------------------------------------------------------------------

NebulaSQLParser::SelectClauseContext::SelectClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SelectClauseContext::SELECT()
{
    return getToken(NebulaSQLParser::SELECT, 0);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::SelectClauseContext::namedExpressionSeq()
{
    return getRuleContext<NebulaSQLParser::NamedExpressionSeqContext>(0);
}

std::vector<NebulaSQLParser::HintContext*> NebulaSQLParser::SelectClauseContext::hint()
{
    return getRuleContexts<NebulaSQLParser::HintContext>();
}

NebulaSQLParser::HintContext* NebulaSQLParser::SelectClauseContext::hint(size_t i)
{
    return getRuleContext<NebulaSQLParser::HintContext>(i);
}


size_t NebulaSQLParser::SelectClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSelectClause;
}

void NebulaSQLParser::SelectClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSelectClause(this);
}

void NebulaSQLParser::SelectClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSelectClause(this);
}

NebulaSQLParser::SelectClauseContext* NebulaSQLParser::selectClause()
{
    SelectClauseContext* _localctx = _tracker.createInstance<SelectClauseContext>(_ctx, getState());
    enterRule(_localctx, 32, NebulaSQLParser::RuleSelectClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(293);
        match(NebulaSQLParser::SELECT);
        setState(297);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(294);
                antlrcpp::downCast<SelectClauseContext*>(_localctx)->hintContext = hint();
                antlrcpp::downCast<SelectClauseContext*>(_localctx)->hints.push_back(
                    antlrcpp::downCast<SelectClauseContext*>(_localctx)->hintContext);
            }
            setState(299);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
        }
        setState(300);
        namedExpressionSeq();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

NebulaSQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WhereClauseContext::WHERE()
{
    return getToken(NebulaSQLParser::WHERE, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::WhereClauseContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::WhereClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWhereClause;
}

void NebulaSQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWhereClause(this);
}

void NebulaSQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWhereClause(this);
}

NebulaSQLParser::WhereClauseContext* NebulaSQLParser::whereClause()
{
    WhereClauseContext* _localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 34, NebulaSQLParser::RuleWhereClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(302);
        match(NebulaSQLParser::WHERE);
        setState(303);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

NebulaSQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::HavingClauseContext::HAVING()
{
    return getToken(NebulaSQLParser::HAVING, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::HavingClauseContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::HavingClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHavingClause;
}

void NebulaSQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHavingClause(this);
}

void NebulaSQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHavingClause(this);
}

NebulaSQLParser::HavingClauseContext* NebulaSQLParser::havingClause()
{
    HavingClauseContext* _localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
    enterRule(_localctx, 36, NebulaSQLParser::RuleHavingClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(305);
        match(NebulaSQLParser::HAVING);
        setState(306);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- InlineTableContext ------------------------------------------------------------------

NebulaSQLParser::InlineTableContext::InlineTableContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::InlineTableContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::InlineTableContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::InlineTableContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::InlineTableContext::tableAlias()
{
    return getRuleContext<NebulaSQLParser::TableAliasContext>(0);
}


size_t NebulaSQLParser::InlineTableContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleInlineTable;
}

void NebulaSQLParser::InlineTableContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterInlineTable(this);
}

void NebulaSQLParser::InlineTableContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitInlineTable(this);
}

NebulaSQLParser::InlineTableContext* NebulaSQLParser::inlineTable()
{
    InlineTableContext* _localctx = _tracker.createInstance<InlineTableContext>(_ctx, getState());
    enterRule(_localctx, 38, NebulaSQLParser::RuleInlineTable);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(308);
        match(NebulaSQLParser::VALUES);
        setState(309);
        expression();
        setState(314);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(310);
                match(NebulaSQLParser::T__1);
                setState(311);
                expression();
            }
            setState(316);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx);
        }
        setState(317);
        tableAlias();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

NebulaSQLParser::TableAliasContext::TableAliasContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::TableAliasContext::strictIdentifier()
{
    return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TableAliasContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::TableAliasContext::identifierList()
{
    return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}


size_t NebulaSQLParser::TableAliasContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTableAlias;
}

void NebulaSQLParser::TableAliasContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTableAlias(this);
}

void NebulaSQLParser::TableAliasContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTableAlias(this);
}

NebulaSQLParser::TableAliasContext* NebulaSQLParser::tableAlias()
{
    TableAliasContext* _localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
    enterRule(_localctx, 40, NebulaSQLParser::RuleTableAlias);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(326);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx))
        {
            case 1: {
                setState(320);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx))
                {
                    case 1: {
                        setState(319);
                        match(NebulaSQLParser::AS);
                        break;
                    }

                    default:
                        break;
                }
                setState(322);
                strictIdentifier();
                setState(324);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx))
                {
                    case 1: {
                        setState(323);
                        identifierList();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MultipartIdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierListContext::MultipartIdentifierListContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::MultipartIdentifierContext*> NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier()
{
    return getRuleContexts<NebulaSQLParser::MultipartIdentifierContext>();
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::MultipartIdentifierListContext::multipartIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::MultipartIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierListContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleMultipartIdentifierList;
}

void NebulaSQLParser::MultipartIdentifierListContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterMultipartIdentifierList(this);
}

void NebulaSQLParser::MultipartIdentifierListContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitMultipartIdentifierList(this);
}

NebulaSQLParser::MultipartIdentifierListContext* NebulaSQLParser::multipartIdentifierList()
{
    MultipartIdentifierListContext* _localctx = _tracker.createInstance<MultipartIdentifierListContext>(_ctx, getState());
    enterRule(_localctx, 42, NebulaSQLParser::RuleMultipartIdentifierList);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(328);
        multipartIdentifier();
        setState(333);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1)
        {
            setState(329);
            match(NebulaSQLParser::T__1);
            setState(330);
            multipartIdentifier();
            setState(335);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- MultipartIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::MultipartIdentifierContext::MultipartIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext*> NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier()
{
    return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::MultipartIdentifierContext::errorCapturingIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::MultipartIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleMultipartIdentifier;
}

void NebulaSQLParser::MultipartIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterMultipartIdentifier(this);
}

void NebulaSQLParser::MultipartIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitMultipartIdentifier(this);
}

NebulaSQLParser::MultipartIdentifierContext* NebulaSQLParser::multipartIdentifier()
{
    MultipartIdentifierContext* _localctx = _tracker.createInstance<MultipartIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 44, NebulaSQLParser::RuleMultipartIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(336);
        antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->parts.push_back(
            antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext);
        setState(341);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(337);
                match(NebulaSQLParser::T__4);
                setState(338);
                antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
                antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->parts.push_back(
                    antlrcpp::downCast<MultipartIdentifierContext*>(_localctx)->errorCapturingIdentifierContext);
            }
            setState(343);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NamedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionContext::NamedExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::NamedExpressionContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::NamedExpressionContext::identifierList()
{
    return getRuleContext<NebulaSQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* NebulaSQLParser::NamedExpressionContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::NamedExpressionContext::errorCapturingIdentifier()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(0);
}


size_t NebulaSQLParser::NamedExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNamedExpression;
}

void NebulaSQLParser::NamedExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNamedExpression(this);
}

void NebulaSQLParser::NamedExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNamedExpression(this);
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::namedExpression()
{
    NamedExpressionContext* _localctx = _tracker.createInstance<NamedExpressionContext>(_ctx, getState());
    enterRule(_localctx, 46, NebulaSQLParser::RuleNamedExpression);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(344);
        expression();
        setState(352);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx))
        {
            case 1: {
                setState(346);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx))
                {
                    case 1: {
                        setState(345);
                        match(NebulaSQLParser::AS);
                        break;
                    }

                    default:
                        break;
                }
                setState(350);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx))
                {
                    case 1: {
                        setState(348);
                        antlrcpp::downCast<NamedExpressionContext*>(_localctx)->name = errorCapturingIdentifier();
                        break;
                    }

                    case 2: {
                        setState(349);
                        identifierList();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext::IdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::IdentifierContext::strictIdentifier()
{
    return getRuleContext<NebulaSQLParser::StrictIdentifierContext>(0);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::IdentifierContext::strictNonReserved()
{
    return getRuleContext<NebulaSQLParser::StrictNonReservedContext>(0);
}


size_t NebulaSQLParser::IdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifier;
}

void NebulaSQLParser::IdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifier(this);
}

void NebulaSQLParser::IdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifier(this);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::identifier()
{
    IdentifierContext* _localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
    enterRule(_localctx, 48, NebulaSQLParser::RuleIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(357);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(354);
                strictIdentifier();
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(355);

                if (!(!SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
                setState(356);
                strictNonReserved();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StrictIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::StrictIdentifierContext::StrictIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::StrictIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStrictIdentifier;
}

void NebulaSQLParser::StrictIdentifierContext::copyFrom(StrictIdentifierContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- QuotedIdentifierAlternativeContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::QuotedIdentifierAlternativeContext::quotedIdentifier()
{
    return getRuleContext<NebulaSQLParser::QuotedIdentifierContext>(0);
}

NebulaSQLParser::QuotedIdentifierAlternativeContext::QuotedIdentifierAlternativeContext(StrictIdentifierContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::QuotedIdentifierAlternativeContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuotedIdentifierAlternative(this);
}
void NebulaSQLParser::QuotedIdentifierAlternativeContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuotedIdentifierAlternative(this);
}
//----------------- UnquotedIdentifierContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnquotedIdentifierContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::ansiNonReserved()
{
    return getRuleContext<NebulaSQLParser::AnsiNonReservedContext>(0);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::UnquotedIdentifierContext::nonReserved()
{
    return getRuleContext<NebulaSQLParser::NonReservedContext>(0);
}

NebulaSQLParser::UnquotedIdentifierContext::UnquotedIdentifierContext(StrictIdentifierContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnquotedIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnquotedIdentifier(this);
}
void NebulaSQLParser::UnquotedIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnquotedIdentifier(this);
}
NebulaSQLParser::StrictIdentifierContext* NebulaSQLParser::strictIdentifier()
{
    StrictIdentifierContext* _localctx = _tracker.createInstance<StrictIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 50, NebulaSQLParser::RuleStrictIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(365);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(359);
                match(NebulaSQLParser::IDENTIFIER);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::QuotedIdentifierAlternativeContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(360);
                quotedIdentifier();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(361);

                if (!(SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "SQL_standard_keyword_behavior");
                setState(362);
                ansiNonReserved();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnquotedIdentifierContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(363);

                if (!(!SQL_standard_keyword_behavior))
                    throw FailedPredicateException(this, "!SQL_standard_keyword_behavior");
                setState(364);
                nonReserved();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- QuotedIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::QuotedIdentifierContext::QuotedIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::QuotedIdentifierContext::BACKQUOTED_IDENTIFIER()
{
    return getToken(NebulaSQLParser::BACKQUOTED_IDENTIFIER, 0);
}


size_t NebulaSQLParser::QuotedIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQuotedIdentifier;
}

void NebulaSQLParser::QuotedIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQuotedIdentifier(this);
}

void NebulaSQLParser::QuotedIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQuotedIdentifier(this);
}

NebulaSQLParser::QuotedIdentifierContext* NebulaSQLParser::quotedIdentifier()
{
    QuotedIdentifierContext* _localctx = _tracker.createInstance<QuotedIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 52, NebulaSQLParser::RuleQuotedIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(367);
        match(NebulaSQLParser::BACKQUOTED_IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::IdentifierListContext::identifierSeq()
{
    return getRuleContext<NebulaSQLParser::IdentifierSeqContext>(0);
}


size_t NebulaSQLParser::IdentifierListContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifierList;
}

void NebulaSQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifierList(this);
}

void NebulaSQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifierList(this);
}

NebulaSQLParser::IdentifierListContext* NebulaSQLParser::identifierList()
{
    IdentifierListContext* _localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
    enterRule(_localctx, 54, NebulaSQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(369);
        match(NebulaSQLParser::T__2);
        setState(370);
        identifierSeq();
        setState(371);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- IdentifierSeqContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierSeqContext::IdentifierSeqContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ErrorCapturingIdentifierContext*> NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier()
{
    return getRuleContexts<NebulaSQLParser::ErrorCapturingIdentifierContext>();
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::IdentifierSeqContext::errorCapturingIdentifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierContext>(i);
}


size_t NebulaSQLParser::IdentifierSeqContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleIdentifierSeq;
}

void NebulaSQLParser::IdentifierSeqContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIdentifierSeq(this);
}

void NebulaSQLParser::IdentifierSeqContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIdentifierSeq(this);
}

NebulaSQLParser::IdentifierSeqContext* NebulaSQLParser::identifierSeq()
{
    IdentifierSeqContext* _localctx = _tracker.createInstance<IdentifierSeqContext>(_ctx, getState());
    enterRule(_localctx, 56, NebulaSQLParser::RuleIdentifierSeq);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(373);
        antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
        antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->ident.push_back(
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext);
        setState(378);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == NebulaSQLParser::T__1)
        {
            setState(374);
            match(NebulaSQLParser::T__1);
            setState(375);
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext = errorCapturingIdentifier();
            antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->ident.push_back(
                antlrcpp::downCast<IdentifierSeqContext*>(_localctx)->errorCapturingIdentifierContext);
            setState(380);
            _errHandler->sync(this);
            _la = _input->LA(1);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ErrorCapturingIdentifierContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierContext::ErrorCapturingIdentifierContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorCapturingIdentifierContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::ErrorCapturingIdentifierContext::errorCapturingIdentifierExtra()
{
    return getRuleContext<NebulaSQLParser::ErrorCapturingIdentifierExtraContext>(0);
}


size_t NebulaSQLParser::ErrorCapturingIdentifierContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleErrorCapturingIdentifier;
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterErrorCapturingIdentifier(this);
}

void NebulaSQLParser::ErrorCapturingIdentifierContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitErrorCapturingIdentifier(this);
}

NebulaSQLParser::ErrorCapturingIdentifierContext* NebulaSQLParser::errorCapturingIdentifier()
{
    ErrorCapturingIdentifierContext* _localctx = _tracker.createInstance<ErrorCapturingIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 58, NebulaSQLParser::RuleErrorCapturingIdentifier);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(381);
        identifier();
        setState(382);
        errorCapturingIdentifierExtra();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ErrorCapturingIdentifierExtraContext ------------------------------------------------------------------

NebulaSQLParser::ErrorCapturingIdentifierExtraContext::ErrorCapturingIdentifierExtraContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ErrorCapturingIdentifierExtraContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleErrorCapturingIdentifierExtra;
}

void NebulaSQLParser::ErrorCapturingIdentifierExtraContext::copyFrom(ErrorCapturingIdentifierExtraContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ErrorIdentContext ------------------------------------------------------------------

std::vector<tree::TerminalNode*> NebulaSQLParser::ErrorIdentContext::MINUS()
{
    return getTokens(NebulaSQLParser::MINUS);
}

tree::TerminalNode* NebulaSQLParser::ErrorIdentContext::MINUS(size_t i)
{
    return getToken(NebulaSQLParser::MINUS, i);
}

std::vector<NebulaSQLParser::IdentifierContext*> NebulaSQLParser::ErrorIdentContext::identifier()
{
    return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ErrorIdentContext::identifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}

NebulaSQLParser::ErrorIdentContext::ErrorIdentContext(ErrorCapturingIdentifierExtraContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ErrorIdentContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterErrorIdent(this);
}
void NebulaSQLParser::ErrorIdentContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitErrorIdent(this);
}
//----------------- RealIdentContext ------------------------------------------------------------------

NebulaSQLParser::RealIdentContext::RealIdentContext(ErrorCapturingIdentifierExtraContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::RealIdentContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRealIdent(this);
}
void NebulaSQLParser::RealIdentContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRealIdent(this);
}
NebulaSQLParser::ErrorCapturingIdentifierExtraContext* NebulaSQLParser::errorCapturingIdentifierExtra()
{
    ErrorCapturingIdentifierExtraContext* _localctx = _tracker.createInstance<ErrorCapturingIdentifierExtraContext>(_ctx, getState());
    enterRule(_localctx, 60, NebulaSQLParser::RuleErrorCapturingIdentifierExtra);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(391);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ErrorIdentContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(386);
                _errHandler->sync(this);
                alt = 1;
                do
                {
                    switch (alt)
                    {
                        case 1: {
                            setState(384);
                            match(NebulaSQLParser::MINUS);
                            setState(385);
                            identifier();
                            break;
                        }

                        default:
                            throw NoViableAltException(this);
                    }
                    setState(388);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
                } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::RealIdentContext>(_localctx);
                enterOuterAlt(_localctx, 2);

                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NamedExpressionSeqContext ------------------------------------------------------------------

NebulaSQLParser::NamedExpressionSeqContext::NamedExpressionSeqContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::NamedExpressionContext*> NebulaSQLParser::NamedExpressionSeqContext::namedExpression()
{
    return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::NamedExpressionSeqContext::namedExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}


size_t NebulaSQLParser::NamedExpressionSeqContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNamedExpressionSeq;
}

void NebulaSQLParser::NamedExpressionSeqContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNamedExpressionSeq(this);
}

void NebulaSQLParser::NamedExpressionSeqContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNamedExpressionSeq(this);
}

NebulaSQLParser::NamedExpressionSeqContext* NebulaSQLParser::namedExpressionSeq()
{
    NamedExpressionSeqContext* _localctx = _tracker.createInstance<NamedExpressionSeqContext>(_ctx, getState());
    enterRule(_localctx, 62, NebulaSQLParser::RuleNamedExpressionSeq);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(393);
        namedExpression();
        setState(398);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(394);
                match(NebulaSQLParser::T__1);
                setState(395);
                namedExpression();
            }
            setState(400);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext::ExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::ExpressionContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}


size_t NebulaSQLParser::ExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleExpression;
}

void NebulaSQLParser::ExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExpression(this);
}

void NebulaSQLParser::ExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExpression(this);
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::expression()
{
    ExpressionContext* _localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
    enterRule(_localctx, 64, NebulaSQLParser::RuleExpression);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(401);
        booleanExpression(0);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanExpressionContext ------------------------------------------------------------------

NebulaSQLParser::BooleanExpressionContext::BooleanExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::BooleanExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleBooleanExpression;
}

void NebulaSQLParser::BooleanExpressionContext::copyFrom(BooleanExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- LogicalNotContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LogicalNotContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalNotContext::booleanExpression()
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(0);
}

NebulaSQLParser::LogicalNotContext::LogicalNotContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LogicalNotContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogicalNot(this);
}
void NebulaSQLParser::LogicalNotContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogicalNot(this);
}
//----------------- PredicatedContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicatedContext::valueExpression()
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::PredicatedContext::predicate()
{
    return getRuleContext<NebulaSQLParser::PredicateContext>(0);
}

NebulaSQLParser::PredicatedContext::PredicatedContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::PredicatedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPredicated(this);
}
void NebulaSQLParser::PredicatedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPredicated(this);
}
//----------------- ExistsContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExistsContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::ExistsContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::ExistsContext::ExistsContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ExistsContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExists(this);
}
void NebulaSQLParser::ExistsContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExists(this);
}
//----------------- LogicalBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::BooleanExpressionContext*> NebulaSQLParser::LogicalBinaryContext::booleanExpression()
{
    return getRuleContexts<NebulaSQLParser::BooleanExpressionContext>();
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::LogicalBinaryContext::booleanExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::BooleanExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::LogicalBinaryContext::OR()
{
    return getToken(NebulaSQLParser::OR, 0);
}

NebulaSQLParser::LogicalBinaryContext::LogicalBinaryContext(BooleanExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LogicalBinaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLogicalBinary(this);
}
void NebulaSQLParser::LogicalBinaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLogicalBinary(this);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression()
{
    return booleanExpression(0);
}

NebulaSQLParser::BooleanExpressionContext* NebulaSQLParser::booleanExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::BooleanExpressionContext* _localctx = _tracker.createInstance<BooleanExpressionContext>(_ctx, parentState);
    NebulaSQLParser::BooleanExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 66;
    enterRecursionRule(_localctx, 66, NebulaSQLParser::RuleBooleanExpression, precedence);


#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(415);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<LogicalNotContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(404);
                match(NebulaSQLParser::NOT);
                setState(405);
                booleanExpression(5);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<ExistsContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(406);
                match(NebulaSQLParser::EXISTS);
                setState(407);
                match(NebulaSQLParser::T__2);
                setState(408);
                query();
                setState(409);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<PredicatedContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(411);
                valueExpression(0);
                setState(413);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx))
                {
                    case 1: {
                        setState(412);
                        predicate();
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(425);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                setState(423);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx))
                {
                    case 1: {
                        auto newContext = _tracker.createInstance<LogicalBinaryContext>(
                            _tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
                        setState(417);

                        if (!(precpred(_ctx, 2)))
                            throw FailedPredicateException(this, "precpred(_ctx, 2)");
                        setState(418);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->op = match(NebulaSQLParser::AND);
                        setState(419);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->right = booleanExpression(3);
                        break;
                    }

                    case 2: {
                        auto newContext = _tracker.createInstance<LogicalBinaryContext>(
                            _tracker.createInstance<BooleanExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleBooleanExpression);
                        setState(420);

                        if (!(precpred(_ctx, 1)))
                            throw FailedPredicateException(this, "precpred(_ctx, 1)");
                        setState(421);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->op = match(NebulaSQLParser::OR);
                        setState(422);
                        antlrcpp::downCast<LogicalBinaryContext*>(_localctx)->right = booleanExpression(2);
                        break;
                    }

                    default:
                        break;
                }
            }
            setState(427);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- WindowedAggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowedAggregationClauseContext::WindowedAggregationClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::windowClause()
{
    return getRuleContext<NebulaSQLParser::WindowClauseContext>(0);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::aggregationClause()
{
    return getRuleContext<NebulaSQLParser::AggregationClauseContext>(0);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::WindowedAggregationClauseContext::watermarkClause()
{
    return getRuleContext<NebulaSQLParser::WatermarkClauseContext>(0);
}


size_t NebulaSQLParser::WindowedAggregationClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowedAggregationClause;
}

void NebulaSQLParser::WindowedAggregationClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWindowedAggregationClause(this);
}

void NebulaSQLParser::WindowedAggregationClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWindowedAggregationClause(this);
}

NebulaSQLParser::WindowedAggregationClauseContext* NebulaSQLParser::windowedAggregationClause()
{
    WindowedAggregationClauseContext* _localctx = _tracker.createInstance<WindowedAggregationClauseContext>(_ctx, getState());
    enterRule(_localctx, 68, NebulaSQLParser::RuleWindowedAggregationClause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(429);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::GROUP)
        {
            setState(428);
            aggregationClause();
        }
        setState(431);
        windowClause();
        setState(433);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx))
        {
            case 1: {
                setState(432);
                watermarkClause();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AggregationClauseContext ------------------------------------------------------------------

NebulaSQLParser::AggregationClauseContext::AggregationClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUP()
{
    return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::AggregationClauseContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::AggregationClauseContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::WITH()
{
    return getToken(NebulaSQLParser::WITH, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

std::vector<NebulaSQLParser::GroupingSetContext*> NebulaSQLParser::AggregationClauseContext::groupingSet()
{
    return getRuleContexts<NebulaSQLParser::GroupingSetContext>();
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::AggregationClauseContext::groupingSet(size_t i)
{
    return getRuleContext<NebulaSQLParser::GroupingSetContext>(i);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AggregationClauseContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}


size_t NebulaSQLParser::AggregationClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAggregationClause;
}

void NebulaSQLParser::AggregationClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAggregationClause(this);
}

void NebulaSQLParser::AggregationClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAggregationClause(this);
}

NebulaSQLParser::AggregationClauseContext* NebulaSQLParser::aggregationClause()
{
    AggregationClauseContext* _localctx = _tracker.createInstance<AggregationClauseContext>(_ctx, getState());
    enterRule(_localctx, 70, NebulaSQLParser::RuleAggregationClause);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(479);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(435);
                match(NebulaSQLParser::GROUP);
                setState(436);
                match(NebulaSQLParser::BY);
                setState(437);
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext = expression();
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->groupingExpressions.push_back(
                    antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext);
                setState(442);
                _errHandler->sync(this);
                alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
                while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
                {
                    if (alt == 1)
                    {
                        setState(438);
                        match(NebulaSQLParser::T__1);
                        setState(439);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext = expression();
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->groupingExpressions.push_back(
                            antlrcpp::downCast<AggregationClauseContext*>(_localctx)->expressionContext);
                    }
                    setState(444);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx);
                }
                setState(462);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx))
                {
                    case 1: {
                        setState(445);
                        match(NebulaSQLParser::WITH);
                        setState(446);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::ROLLUP);
                        break;
                    }

                    case 2: {
                        setState(447);
                        match(NebulaSQLParser::WITH);
                        setState(448);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::CUBE);
                        break;
                    }

                    case 3: {
                        setState(449);
                        antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
                        setState(450);
                        match(NebulaSQLParser::SETS);
                        setState(451);
                        match(NebulaSQLParser::T__2);
                        setState(452);
                        groupingSet();
                        setState(457);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(453);
                            match(NebulaSQLParser::T__1);
                            setState(454);
                            groupingSet();
                            setState(459);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        setState(460);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(464);
                match(NebulaSQLParser::GROUP);
                setState(465);
                match(NebulaSQLParser::BY);
                setState(466);
                antlrcpp::downCast<AggregationClauseContext*>(_localctx)->kind = match(NebulaSQLParser::GROUPING);
                setState(467);
                match(NebulaSQLParser::SETS);
                setState(468);
                match(NebulaSQLParser::T__2);
                setState(469);
                groupingSet();
                setState(474);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(470);
                    match(NebulaSQLParser::T__1);
                    setState(471);
                    groupingSet();
                    setState(476);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(477);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- GroupingSetContext ------------------------------------------------------------------

NebulaSQLParser::GroupingSetContext::GroupingSetContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::GroupingSetContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::GroupingSetContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}


size_t NebulaSQLParser::GroupingSetContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleGroupingSet;
}

void NebulaSQLParser::GroupingSetContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterGroupingSet(this);
}

void NebulaSQLParser::GroupingSetContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitGroupingSet(this);
}

NebulaSQLParser::GroupingSetContext* NebulaSQLParser::groupingSet()
{
    GroupingSetContext* _localctx = _tracker.createInstance<GroupingSetContext>(_ctx, getState());
    enterRule(_localctx, 72, NebulaSQLParser::RuleGroupingSet);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(494);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(481);
                match(NebulaSQLParser::T__2);
                setState(490);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx))
                {
                    case 1: {
                        setState(482);
                        expression();
                        setState(487);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(483);
                            match(NebulaSQLParser::T__1);
                            setState(484);
                            expression();
                            setState(489);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        break;
                    }

                    default:
                        break;
                }
                setState(492);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(493);
                expression();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

NebulaSQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WindowClauseContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}

NebulaSQLParser::WindowSpecContext* NebulaSQLParser::WindowClauseContext::windowSpec()
{
    return getRuleContext<NebulaSQLParser::WindowSpecContext>(0);
}


size_t NebulaSQLParser::WindowClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowClause;
}

void NebulaSQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWindowClause(this);
}

void NebulaSQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWindowClause(this);
}

NebulaSQLParser::WindowClauseContext* NebulaSQLParser::windowClause()
{
    WindowClauseContext* _localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
    enterRule(_localctx, 74, NebulaSQLParser::RuleWindowClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(496);
        match(NebulaSQLParser::WINDOW);
        setState(497);
        windowSpec();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WatermarkClauseContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkClauseContext::WatermarkClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::WatermarkClauseContext::WATERMARK()
{
    return getToken(NebulaSQLParser::WATERMARK, 0);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::WatermarkClauseContext::watermarkParameters()
{
    return getRuleContext<NebulaSQLParser::WatermarkParametersContext>(0);
}


size_t NebulaSQLParser::WatermarkClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWatermarkClause;
}

void NebulaSQLParser::WatermarkClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWatermarkClause(this);
}

void NebulaSQLParser::WatermarkClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWatermarkClause(this);
}

NebulaSQLParser::WatermarkClauseContext* NebulaSQLParser::watermarkClause()
{
    WatermarkClauseContext* _localctx = _tracker.createInstance<WatermarkClauseContext>(_ctx, getState());
    enterRule(_localctx, 76, NebulaSQLParser::RuleWatermarkClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(499);
        match(NebulaSQLParser::WATERMARK);
        setState(500);
        match(NebulaSQLParser::T__2);
        setState(501);
        watermarkParameters();
        setState(502);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WatermarkParametersContext ------------------------------------------------------------------

NebulaSQLParser::WatermarkParametersContext::WatermarkParametersContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::WatermarkParametersContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::WatermarkParametersContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::WatermarkParametersContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::WatermarkParametersContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWatermarkParameters;
}

void NebulaSQLParser::WatermarkParametersContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterWatermarkParameters(this);
}

void NebulaSQLParser::WatermarkParametersContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitWatermarkParameters(this);
}

NebulaSQLParser::WatermarkParametersContext* NebulaSQLParser::watermarkParameters()
{
    WatermarkParametersContext* _localctx = _tracker.createInstance<WatermarkParametersContext>(_ctx, getState());
    enterRule(_localctx, 78, NebulaSQLParser::RuleWatermarkParameters);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(504);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermarkIdentifier = identifier();
        setState(505);
        match(NebulaSQLParser::T__1);
        setState(506);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermark = match(NebulaSQLParser::INTEGER_VALUE);
        setState(507);
        antlrcpp::downCast<WatermarkParametersContext*>(_localctx)->watermarkTimeUnit = timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

NebulaSQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::WindowSpecContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleWindowSpec;
}

void NebulaSQLParser::WindowSpecContext::copyFrom(WindowSpecContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TimeBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext* NebulaSQLParser::TimeBasedWindowContext::timeWindow()
{
    return getRuleContext<NebulaSQLParser::TimeWindowContext>(0);
}

NebulaSQLParser::TimeBasedWindowContext::TimeBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TimeBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimeBasedWindow(this);
}
void NebulaSQLParser::TimeBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimeBasedWindow(this);
}
//----------------- CountBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext* NebulaSQLParser::CountBasedWindowContext::countWindow()
{
    return getRuleContext<NebulaSQLParser::CountWindowContext>(0);
}

NebulaSQLParser::CountBasedWindowContext::CountBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::CountBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterCountBasedWindow(this);
}
void NebulaSQLParser::CountBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitCountBasedWindow(this);
}
//----------------- ThresholdBasedWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::ThresholdBasedWindowContext::conditionWindow()
{
    return getRuleContext<NebulaSQLParser::ConditionWindowContext>(0);
}

NebulaSQLParser::ThresholdBasedWindowContext::ThresholdBasedWindowContext(WindowSpecContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ThresholdBasedWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdBasedWindow(this);
}
void NebulaSQLParser::ThresholdBasedWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdBasedWindow(this);
}
NebulaSQLParser::WindowSpecContext* NebulaSQLParser::windowSpec()
{
    WindowSpecContext* _localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
    enterRule(_localctx, 80, NebulaSQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(512);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TimeBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(509);
                timeWindow();
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(510);
                countWindow();
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdBasedWindowContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(511);
                conditionWindow();
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimeWindowContext ------------------------------------------------------------------

NebulaSQLParser::TimeWindowContext::TimeWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::TimeWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimeWindow;
}

void NebulaSQLParser::TimeWindowContext::copyFrom(TimeWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- TumblingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TumblingWindowContext::TUMBLING()
{
    return getToken(NebulaSQLParser::TUMBLING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::TumblingWindowContext::sizeParameter()
{
    return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::TumblingWindowContext::timestampParameter()
{
    return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::TumblingWindowContext::TumblingWindowContext(TimeWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TumblingWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTumblingWindow(this);
}
void NebulaSQLParser::TumblingWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTumblingWindow(this);
}
//----------------- SlidingWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SlidingWindowContext::SLIDING()
{
    return getToken(NebulaSQLParser::SLIDING, 0);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::SlidingWindowContext::sizeParameter()
{
    return getRuleContext<NebulaSQLParser::SizeParameterContext>(0);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::SlidingWindowContext::advancebyParameter()
{
    return getRuleContext<NebulaSQLParser::AdvancebyParameterContext>(0);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::SlidingWindowContext::timestampParameter()
{
    return getRuleContext<NebulaSQLParser::TimestampParameterContext>(0);
}

NebulaSQLParser::SlidingWindowContext::SlidingWindowContext(TimeWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SlidingWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSlidingWindow(this);
}
void NebulaSQLParser::SlidingWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSlidingWindow(this);
}
NebulaSQLParser::TimeWindowContext* NebulaSQLParser::timeWindow()
{
    TimeWindowContext* _localctx = _tracker.createInstance<TimeWindowContext>(_ctx, getState());
    enterRule(_localctx, 82, NebulaSQLParser::RuleTimeWindow);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(536);
        _errHandler->sync(this);
        switch (_input->LA(1))
        {
            case NebulaSQLParser::TUMBLING: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TumblingWindowContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(514);
                match(NebulaSQLParser::TUMBLING);
                setState(515);
                match(NebulaSQLParser::T__2);
                setState(519);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::IDENTIFIER)
                {
                    setState(516);
                    timestampParameter();
                    setState(517);
                    match(NebulaSQLParser::T__1);
                }
                setState(521);
                sizeParameter();
                setState(522);
                match(NebulaSQLParser::T__3);
                break;
            }

            case NebulaSQLParser::SLIDING: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SlidingWindowContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(524);
                match(NebulaSQLParser::SLIDING);
                setState(525);
                match(NebulaSQLParser::T__2);
                setState(529);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::IDENTIFIER)
                {
                    setState(526);
                    timestampParameter();
                    setState(527);
                    match(NebulaSQLParser::T__1);
                }
                setState(531);
                sizeParameter();
                setState(532);
                match(NebulaSQLParser::T__1);
                setState(533);
                advancebyParameter();
                setState(534);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                throw NoViableAltException(this);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- CountWindowContext ------------------------------------------------------------------

NebulaSQLParser::CountWindowContext::CountWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::CountWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleCountWindow;
}

void NebulaSQLParser::CountWindowContext::copyFrom(CountWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- CountBasedTumblingContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::TUMBLING()
{
    return getToken(NebulaSQLParser::TUMBLING, 0);
}

tree::TerminalNode* NebulaSQLParser::CountBasedTumblingContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::CountBasedTumblingContext::CountBasedTumblingContext(CountWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::CountBasedTumblingContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterCountBasedTumbling(this);
}
void NebulaSQLParser::CountBasedTumblingContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitCountBasedTumbling(this);
}
NebulaSQLParser::CountWindowContext* NebulaSQLParser::countWindow()
{
    CountWindowContext* _localctx = _tracker.createInstance<CountWindowContext>(_ctx, getState());
    enterRule(_localctx, 84, NebulaSQLParser::RuleCountWindow);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        _localctx = _tracker.createInstance<NebulaSQLParser::CountBasedTumblingContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(538);
        match(NebulaSQLParser::TUMBLING);
        setState(539);
        match(NebulaSQLParser::T__2);
        setState(540);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(541);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConditionWindowContext ------------------------------------------------------------------

NebulaSQLParser::ConditionWindowContext::ConditionWindowContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ConditionWindowContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConditionWindow;
}

void NebulaSQLParser::ConditionWindowContext::copyFrom(ConditionWindowContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ThresholdWindowContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ThresholdWindowContext::THRESHOLD()
{
    return getToken(NebulaSQLParser::THRESHOLD, 0);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::ThresholdWindowContext::conditionParameter()
{
    return getRuleContext<NebulaSQLParser::ConditionParameterContext>(0);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::ThresholdWindowContext::thresholdMinSizeParameter()
{
    return getRuleContext<NebulaSQLParser::ThresholdMinSizeParameterContext>(0);
}

NebulaSQLParser::ThresholdWindowContext::ThresholdWindowContext(ConditionWindowContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ThresholdWindowContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdWindow(this);
}
void NebulaSQLParser::ThresholdWindowContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdWindow(this);
}
NebulaSQLParser::ConditionWindowContext* NebulaSQLParser::conditionWindow()
{
    ConditionWindowContext* _localctx = _tracker.createInstance<ConditionWindowContext>(_ctx, getState());
    enterRule(_localctx, 86, NebulaSQLParser::RuleConditionWindow);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        _localctx = _tracker.createInstance<NebulaSQLParser::ThresholdWindowContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(543);
        match(NebulaSQLParser::THRESHOLD);
        setState(544);
        match(NebulaSQLParser::T__2);
        setState(545);
        conditionParameter();
        setState(548);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::T__1)
        {
            setState(546);
            match(NebulaSQLParser::T__1);
            setState(547);
            thresholdMinSizeParameter();
        }
        setState(550);
        match(NebulaSQLParser::T__3);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConditionParameterContext ------------------------------------------------------------------

NebulaSQLParser::ConditionParameterContext::ConditionParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ConditionParameterContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}


size_t NebulaSQLParser::ConditionParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConditionParameter;
}

void NebulaSQLParser::ConditionParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterConditionParameter(this);
}

void NebulaSQLParser::ConditionParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitConditionParameter(this);
}

NebulaSQLParser::ConditionParameterContext* NebulaSQLParser::conditionParameter()
{
    ConditionParameterContext* _localctx = _tracker.createInstance<ConditionParameterContext>(_ctx, getState());
    enterRule(_localctx, 88, NebulaSQLParser::RuleConditionParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(552);
        expression();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ThresholdMinSizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::ThresholdMinSizeParameterContext::ThresholdMinSizeParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::ThresholdMinSizeParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}


size_t NebulaSQLParser::ThresholdMinSizeParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleThresholdMinSizeParameter;
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterThresholdMinSizeParameter(this);
}

void NebulaSQLParser::ThresholdMinSizeParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitThresholdMinSizeParameter(this);
}

NebulaSQLParser::ThresholdMinSizeParameterContext* NebulaSQLParser::thresholdMinSizeParameter()
{
    ThresholdMinSizeParameterContext* _localctx = _tracker.createInstance<ThresholdMinSizeParameterContext>(_ctx, getState());
    enterRule(_localctx, 90, NebulaSQLParser::RuleThresholdMinSizeParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(554);
        match(NebulaSQLParser::INTEGER_VALUE);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SizeParameterContext ------------------------------------------------------------------

NebulaSQLParser::SizeParameterContext::SizeParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::SIZE()
{
    return getToken(NebulaSQLParser::SIZE, 0);
}

tree::TerminalNode* NebulaSQLParser::SizeParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::SizeParameterContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::SizeParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSizeParameter;
}

void NebulaSQLParser::SizeParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSizeParameter(this);
}

void NebulaSQLParser::SizeParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSizeParameter(this);
}

NebulaSQLParser::SizeParameterContext* NebulaSQLParser::sizeParameter()
{
    SizeParameterContext* _localctx = _tracker.createInstance<SizeParameterContext>(_ctx, getState());
    enterRule(_localctx, 92, NebulaSQLParser::RuleSizeParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(556);
        match(NebulaSQLParser::SIZE);
        setState(557);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(558);
        timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AdvancebyParameterContext ------------------------------------------------------------------

NebulaSQLParser::AdvancebyParameterContext::AdvancebyParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::ADVANCE()
{
    return getToken(NebulaSQLParser::ADVANCE, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AdvancebyParameterContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::AdvancebyParameterContext::timeUnit()
{
    return getRuleContext<NebulaSQLParser::TimeUnitContext>(0);
}


size_t NebulaSQLParser::AdvancebyParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAdvancebyParameter;
}

void NebulaSQLParser::AdvancebyParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAdvancebyParameter(this);
}

void NebulaSQLParser::AdvancebyParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAdvancebyParameter(this);
}

NebulaSQLParser::AdvancebyParameterContext* NebulaSQLParser::advancebyParameter()
{
    AdvancebyParameterContext* _localctx = _tracker.createInstance<AdvancebyParameterContext>(_ctx, getState());
    enterRule(_localctx, 94, NebulaSQLParser::RuleAdvancebyParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(560);
        match(NebulaSQLParser::ADVANCE);
        setState(561);
        match(NebulaSQLParser::BY);
        setState(562);
        match(NebulaSQLParser::INTEGER_VALUE);
        setState(563);
        timeUnit();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimeUnitContext ------------------------------------------------------------------

NebulaSQLParser::TimeUnitContext::TimeUnitContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MS()
{
    return getToken(NebulaSQLParser::MS, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::SEC()
{
    return getToken(NebulaSQLParser::SEC, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::MIN()
{
    return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::HOUR()
{
    return getToken(NebulaSQLParser::HOUR, 0);
}

tree::TerminalNode* NebulaSQLParser::TimeUnitContext::DAY()
{
    return getToken(NebulaSQLParser::DAY, 0);
}


size_t NebulaSQLParser::TimeUnitContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimeUnit;
}

void NebulaSQLParser::TimeUnitContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimeUnit(this);
}

void NebulaSQLParser::TimeUnitContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimeUnit(this);
}

NebulaSQLParser::TimeUnitContext* NebulaSQLParser::timeUnit()
{
    TimeUnitContext* _localctx = _tracker.createInstance<TimeUnitContext>(_ctx, getState());
    enterRule(_localctx, 96, NebulaSQLParser::RuleTimeUnit);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(565);
        _la = _input->LA(1);
        if (!(((((_la - 84) & ~0x3fULL) == 0) && ((1ULL << (_la - 84)) & 31) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- TimestampParameterContext ------------------------------------------------------------------

NebulaSQLParser::TimestampParameterContext::TimestampParameterContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::TimestampParameterContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::TimestampParameterContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleTimestampParameter;
}

void NebulaSQLParser::TimestampParameterContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTimestampParameter(this);
}

void NebulaSQLParser::TimestampParameterContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTimestampParameter(this);
}

NebulaSQLParser::TimestampParameterContext* NebulaSQLParser::timestampParameter()
{
    TimestampParameterContext* _localctx = _tracker.createInstance<TimestampParameterContext>(_ctx, getState());
    enterRule(_localctx, 98, NebulaSQLParser::RuleTimestampParameter);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(567);
        match(NebulaSQLParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::AVG()
{
    return getToken(NebulaSQLParser::AVG, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MAX()
{
    return getToken(NebulaSQLParser::MAX, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MIN()
{
    return getToken(NebulaSQLParser::MIN, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::SUM()
{
    return getToken(NebulaSQLParser::SUM, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::COUNT()
{
    return getToken(NebulaSQLParser::COUNT, 0);
}

tree::TerminalNode* NebulaSQLParser::FunctionNameContext::MEDIAN()
{
    return getToken(NebulaSQLParser::MEDIAN, 0);
}


size_t NebulaSQLParser::FunctionNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFunctionName;
}

void NebulaSQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionName(this);
}

void NebulaSQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionName(this);
}

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::functionName()
{
    FunctionNameContext* _localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
    enterRule(_localctx, 100, NebulaSQLParser::RuleFunctionName);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(569);
        _la = _input->LA(1);
        if (!(((((_la - 86) & ~0x3fULL) == 0) && ((1ULL << (_la - 86)) & 249) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkClauseContext ------------------------------------------------------------------

NebulaSQLParser::SinkClauseContext::SinkClauseContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::SinkClauseContext::INTO()
{
    return getToken(NebulaSQLParser::INTO, 0);
}

std::vector<NebulaSQLParser::SinkContext*> NebulaSQLParser::SinkClauseContext::sink()
{
    return getRuleContexts<NebulaSQLParser::SinkContext>();
}

NebulaSQLParser::SinkContext* NebulaSQLParser::SinkClauseContext::sink(size_t i)
{
    return getRuleContext<NebulaSQLParser::SinkContext>(i);
}


size_t NebulaSQLParser::SinkClauseContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSinkClause;
}

void NebulaSQLParser::SinkClauseContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSinkClause(this);
}

void NebulaSQLParser::SinkClauseContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSinkClause(this);
}

NebulaSQLParser::SinkClauseContext* NebulaSQLParser::sinkClause()
{
    SinkClauseContext* _localctx = _tracker.createInstance<SinkClauseContext>(_ctx, getState());
    enterRule(_localctx, 102, NebulaSQLParser::RuleSinkClause);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(571);
        match(NebulaSQLParser::INTO);
        setState(572);
        sink();
        setState(577);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(573);
                match(NebulaSQLParser::T__1);
                setState(574);
                sink();
            }
            setState(579);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SinkContext ------------------------------------------------------------------

NebulaSQLParser::SinkContext::SinkContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::SinkContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}


size_t NebulaSQLParser::SinkContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSink;
}

void NebulaSQLParser::SinkContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSink(this);
}

void NebulaSQLParser::SinkContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSink(this);
}

NebulaSQLParser::SinkContext* NebulaSQLParser::sink()
{
    SinkContext* _localctx = _tracker.createInstance<SinkContext>(_ctx, getState());
    enterRule(_localctx, 104, NebulaSQLParser::RuleSink);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(580);
        identifier();
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NullNotnullContext ------------------------------------------------------------------

NebulaSQLParser::NullNotnullContext::NullNotnullContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NullNotnullContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}


size_t NebulaSQLParser::NullNotnullContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNullNotnull;
}

void NebulaSQLParser::NullNotnullContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNullNotnull(this);
}

void NebulaSQLParser::NullNotnullContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNullNotnull(this);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::nullNotnull()
{
    NullNotnullContext* _localctx = _tracker.createInstance<NullNotnullContext>(_ctx, getState());
    enterRule(_localctx, 106, NebulaSQLParser::RuleNullNotnull);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(583);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::NOT)
        {
            setState(582);
            match(NebulaSQLParser::NOT);
        }
        setState(585);
        match(NebulaSQLParser::NULLTOKEN);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StreamNameContext ------------------------------------------------------------------

NebulaSQLParser::StreamNameContext::StreamNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::StreamNameContext::IDENTIFIER()
{
    return getToken(NebulaSQLParser::IDENTIFIER, 0);
}


size_t NebulaSQLParser::StreamNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStreamName;
}

void NebulaSQLParser::StreamNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStreamName(this);
}

void NebulaSQLParser::StreamNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStreamName(this);
}

NebulaSQLParser::StreamNameContext* NebulaSQLParser::streamName()
{
    StreamNameContext* _localctx = _tracker.createInstance<StreamNameContext>(_ctx, getState());
    enterRule(_localctx, 108, NebulaSQLParser::RuleStreamName);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(587);
        match(NebulaSQLParser::IDENTIFIER);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- FileFormatContext ------------------------------------------------------------------

NebulaSQLParser::FileFormatContext::FileFormatContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::FileFormatContext::CSV_FORMAT()
{
    return getToken(NebulaSQLParser::CSV_FORMAT, 0);
}


size_t NebulaSQLParser::FileFormatContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleFileFormat;
}

void NebulaSQLParser::FileFormatContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFileFormat(this);
}

void NebulaSQLParser::FileFormatContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFileFormat(this);
}

NebulaSQLParser::FileFormatContext* NebulaSQLParser::fileFormat()
{
    FileFormatContext* _localctx = _tracker.createInstance<FileFormatContext>(_ctx, getState());
    enterRule(_localctx, 110, NebulaSQLParser::RuleFileFormat);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(589);
        match(NebulaSQLParser::CSV_FORMAT);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- SortItemContext ------------------------------------------------------------------

NebulaSQLParser::SortItemContext::SortItemContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::SortItemContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::SortItemContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}


size_t NebulaSQLParser::SortItemContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleSortItem;
}

void NebulaSQLParser::SortItemContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSortItem(this);
}

void NebulaSQLParser::SortItemContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSortItem(this);
}

NebulaSQLParser::SortItemContext* NebulaSQLParser::sortItem()
{
    SortItemContext* _localctx = _tracker.createInstance<SortItemContext>(_ctx, getState());
    enterRule(_localctx, 112, NebulaSQLParser::RuleSortItem);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(591);
        expression();
        setState(593);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::ASC

            || _la == NebulaSQLParser::DESC)
        {
            setState(592);
            antlrcpp::downCast<SortItemContext*>(_localctx)->ordering = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == NebulaSQLParser::ASC

                  || _la == NebulaSQLParser::DESC))
            {
                antlrcpp::downCast<SortItemContext*>(_localctx)->ordering = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
        setState(597);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NebulaSQLParser::NULLS)
        {
            setState(595);
            match(NebulaSQLParser::NULLS);
            setState(596);
            antlrcpp::downCast<SortItemContext*>(_localctx)->nullOrder = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == NebulaSQLParser::FIRST

                  || _la == NebulaSQLParser::LAST))
            {
                antlrcpp::downCast<SortItemContext*>(_localctx)->nullOrder = _errHandler->recoverInline(this);
            }
            else
            {
                _errHandler->reportMatch(this);
                consume();
            }
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

NebulaSQLParser::PredicateContext::PredicateContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::PredicateContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::PredicateContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::PredicateContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::PredicateContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IN()
{
    return getToken(NebulaSQLParser::IN, 0);
}

NebulaSQLParser::QueryContext* NebulaSQLParser::PredicateContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ANY()
{
    return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::SOME()
{
    return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::ESCAPE()
{
    return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::STRING()
{
    return getToken(NebulaSQLParser::STRING, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::IS()
{
    return getToken(NebulaSQLParser::IS, 0);
}

NebulaSQLParser::NullNotnullContext* NebulaSQLParser::PredicateContext::nullNotnull()
{
    return getRuleContext<NebulaSQLParser::NullNotnullContext>(0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::UNKNOWN()
{
    return getToken(NebulaSQLParser::UNKNOWN, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::PredicateContext::DISTINCT()
{
    return getToken(NebulaSQLParser::DISTINCT, 0);
}


size_t NebulaSQLParser::PredicateContext::getRuleIndex() const
{
    return NebulaSQLParser::RulePredicate;
}

void NebulaSQLParser::PredicateContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterPredicate(this);
}

void NebulaSQLParser::PredicateContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitPredicate(this);
}

NebulaSQLParser::PredicateContext* NebulaSQLParser::predicate()
{
    PredicateContext* _localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
    enterRule(_localctx, 114, NebulaSQLParser::RulePredicate);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(678);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(600);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(599);
                    match(NebulaSQLParser::NOT);
                }
                setState(602);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::BETWEEN);
                setState(603);
                antlrcpp::downCast<PredicateContext*>(_localctx)->lower = valueExpression(0);
                setState(604);
                match(NebulaSQLParser::AND);
                setState(605);
                antlrcpp::downCast<PredicateContext*>(_localctx)->upper = valueExpression(0);
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(608);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(607);
                    match(NebulaSQLParser::NOT);
                }
                setState(610);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::IN);
                setState(611);
                match(NebulaSQLParser::T__2);
                setState(612);
                expression();
                setState(617);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(613);
                    match(NebulaSQLParser::T__1);
                    setState(614);
                    expression();
                    setState(619);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(620);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 3: {
                enterOuterAlt(_localctx, 3);
                setState(623);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(622);
                    match(NebulaSQLParser::NOT);
                }
                setState(625);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::IN);
                setState(626);
                match(NebulaSQLParser::T__2);
                setState(627);
                query();
                setState(628);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 4: {
                enterOuterAlt(_localctx, 4);
                setState(631);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(630);
                    match(NebulaSQLParser::NOT);
                }
                setState(633);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::RLIKE);
                setState(634);
                antlrcpp::downCast<PredicateContext*>(_localctx)->pattern = valueExpression(0);
                break;
            }

            case 5: {
                enterOuterAlt(_localctx, 5);
                setState(636);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(635);
                    match(NebulaSQLParser::NOT);
                }
                setState(638);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::LIKE);
                setState(639);
                antlrcpp::downCast<PredicateContext*>(_localctx)->quantifier = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 9) & ~0x3fULL) == 0) && ((1ULL << (_la - 9)) & 36028797018963973) != 0)))
                {
                    antlrcpp::downCast<PredicateContext*>(_localctx)->quantifier = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                setState(653);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx))
                {
                    case 1: {
                        setState(640);
                        match(NebulaSQLParser::T__2);
                        setState(641);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    case 2: {
                        setState(642);
                        match(NebulaSQLParser::T__2);
                        setState(643);
                        expression();
                        setState(648);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(644);
                            match(NebulaSQLParser::T__1);
                            setState(645);
                            expression();
                            setState(650);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        setState(651);
                        match(NebulaSQLParser::T__3);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 6: {
                enterOuterAlt(_localctx, 6);
                setState(656);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(655);
                    match(NebulaSQLParser::NOT);
                }
                setState(658);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::LIKE);
                setState(659);
                antlrcpp::downCast<PredicateContext*>(_localctx)->pattern = valueExpression(0);
                setState(662);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx))
                {
                    case 1: {
                        setState(660);
                        match(NebulaSQLParser::ESCAPE);
                        setState(661);
                        antlrcpp::downCast<PredicateContext*>(_localctx)->escapeChar = match(NebulaSQLParser::STRING);
                        break;
                    }

                    default:
                        break;
                }
                break;
            }

            case 7: {
                enterOuterAlt(_localctx, 7);
                setState(664);
                match(NebulaSQLParser::IS);
                setState(665);
                nullNotnull();
                break;
            }

            case 8: {
                enterOuterAlt(_localctx, 8);
                setState(666);
                match(NebulaSQLParser::IS);
                setState(668);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(667);
                    match(NebulaSQLParser::NOT);
                }
                setState(670);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 28) & ~0x3fULL) == 0) && ((1ULL << (_la - 28)) & 9895604649985) != 0)))
                {
                    antlrcpp::downCast<PredicateContext*>(_localctx)->kind = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                break;
            }

            case 9: {
                enterOuterAlt(_localctx, 9);
                setState(671);
                match(NebulaSQLParser::IS);
                setState(673);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::NOT)
                {
                    setState(672);
                    match(NebulaSQLParser::NOT);
                }
                setState(675);
                antlrcpp::downCast<PredicateContext*>(_localctx)->kind = match(NebulaSQLParser::DISTINCT);
                setState(676);
                match(NebulaSQLParser::FROM);
                setState(677);
                antlrcpp::downCast<PredicateContext*>(_localctx)->right = valueExpression(0);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ValueExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext::ValueExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ValueExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleValueExpression;
}

void NebulaSQLParser::ValueExpressionContext::copyFrom(ValueExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- ValueExpressionDefaultContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::ValueExpressionDefaultContext::primaryExpression()
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::ValueExpressionDefaultContext::ValueExpressionDefaultContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ValueExpressionDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterValueExpressionDefault(this);
}
void NebulaSQLParser::ValueExpressionDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitValueExpressionDefault(this);
}
//----------------- ComparisonContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::ComparisonContext::comparisonOperator()
{
    return getRuleContext<NebulaSQLParser::ComparisonOperatorContext>(0);
}

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::ComparisonContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ComparisonContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

NebulaSQLParser::ComparisonContext::ComparisonContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ComparisonContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterComparison(this);
}
void NebulaSQLParser::ComparisonContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitComparison(this);
}
//----------------- ArithmeticBinaryContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::ValueExpressionContext*> NebulaSQLParser::ArithmeticBinaryContext::valueExpression()
{
    return getRuleContexts<NebulaSQLParser::ValueExpressionContext>();
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticBinaryContext::valueExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(i);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::ASTERISK()
{
    return getToken(NebulaSQLParser::ASTERISK, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::SLASH()
{
    return getToken(NebulaSQLParser::SLASH, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PERCENT()
{
    return getToken(NebulaSQLParser::PERCENT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PLUS()
{
    return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::CONCAT_PIPE()
{
    return getToken(NebulaSQLParser::CONCAT_PIPE, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::AMPERSAND()
{
    return getToken(NebulaSQLParser::AMPERSAND, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::HAT()
{
    return getToken(NebulaSQLParser::HAT, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticBinaryContext::PIPE()
{
    return getToken(NebulaSQLParser::PIPE, 0);
}

NebulaSQLParser::ArithmeticBinaryContext::ArithmeticBinaryContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ArithmeticBinaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterArithmeticBinary(this);
}
void NebulaSQLParser::ArithmeticBinaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitArithmeticBinary(this);
}
//----------------- ArithmeticUnaryContext ------------------------------------------------------------------

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::ArithmeticUnaryContext::valueExpression()
{
    return getRuleContext<NebulaSQLParser::ValueExpressionContext>(0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::PLUS()
{
    return getToken(NebulaSQLParser::PLUS, 0);
}

tree::TerminalNode* NebulaSQLParser::ArithmeticUnaryContext::TILDE()
{
    return getToken(NebulaSQLParser::TILDE, 0);
}

NebulaSQLParser::ArithmeticUnaryContext::ArithmeticUnaryContext(ValueExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ArithmeticUnaryContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterArithmeticUnary(this);
}
void NebulaSQLParser::ArithmeticUnaryContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitArithmeticUnary(this);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression()
{
    return valueExpression(0);
}

NebulaSQLParser::ValueExpressionContext* NebulaSQLParser::valueExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::ValueExpressionContext* _localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
    NebulaSQLParser::ValueExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 116;
    enterRecursionRule(_localctx, 116, NebulaSQLParser::RuleValueExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(684);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<ValueExpressionDefaultContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(681);
                primaryExpression(0);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<ArithmeticUnaryContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(682);
                antlrcpp::downCast<ArithmeticUnaryContext*>(_localctx)->op = _input->LT(1);
                _la = _input->LA(1);
                if (!(((((_la - 111) & ~0x3fULL) == 0) && ((1ULL << (_la - 111)) & 35) != 0)))
                {
                    antlrcpp::downCast<ArithmeticUnaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                setState(683);
                valueExpression(7);
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(707);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                setState(705);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx))
                {
                    case 1: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(686);

                        if (!(precpred(_ctx, 6)))
                            throw FailedPredicateException(this, "precpred(_ctx, 6)");
                        setState(687);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _input->LT(1);
                        _la = _input->LA(1);
                        if (!(_la == NebulaSQLParser::DIV || ((((_la - 113) & ~0x3fULL) == 0) && ((1ULL << (_la - 113)) & 7) != 0)))
                        {
                            antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                        }
                        else
                        {
                            _errHandler->reportMatch(this);
                            consume();
                        }
                        setState(688);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(7);
                        break;
                    }

                    case 2: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(689);

                        if (!(precpred(_ctx, 5)))
                            throw FailedPredicateException(this, "precpred(_ctx, 5)");
                        setState(690);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _input->LT(1);
                        _la = _input->LA(1);
                        if (!(((((_la - 111) & ~0x3fULL) == 0) && ((1ULL << (_la - 111)) & 259) != 0)))
                        {
                            antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = _errHandler->recoverInline(this);
                        }
                        else
                        {
                            _errHandler->reportMatch(this);
                            consume();
                        }
                        setState(691);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(6);
                        break;
                    }

                    case 3: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(692);

                        if (!(precpred(_ctx, 4)))
                            throw FailedPredicateException(this, "precpred(_ctx, 4)");
                        setState(693);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::AMPERSAND);
                        setState(694);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(5);
                        break;
                    }

                    case 4: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(695);

                        if (!(precpred(_ctx, 3)))
                            throw FailedPredicateException(this, "precpred(_ctx, 3)");
                        setState(696);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::HAT);
                        setState(697);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(4);
                        break;
                    }

                    case 5: {
                        auto newContext = _tracker.createInstance<ArithmeticBinaryContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(698);

                        if (!(precpred(_ctx, 2)))
                            throw FailedPredicateException(this, "precpred(_ctx, 2)");
                        setState(699);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->op = match(NebulaSQLParser::PIPE);
                        setState(700);
                        antlrcpp::downCast<ArithmeticBinaryContext*>(_localctx)->right = valueExpression(3);
                        break;
                    }

                    case 6: {
                        auto newContext = _tracker.createInstance<ComparisonContext>(
                            _tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
                        _localctx = newContext;
                        newContext->left = previousContext;
                        pushNewRecursionContext(newContext, startState, RuleValueExpression);
                        setState(701);

                        if (!(precpred(_ctx, 1)))
                            throw FailedPredicateException(this, "precpred(_ctx, 1)");
                        setState(702);
                        comparisonOperator();
                        setState(703);
                        antlrcpp::downCast<ComparisonContext*>(_localctx)->right = valueExpression(2);
                        break;
                    }

                    default:
                        break;
                }
            }
            setState(709);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- ComparisonOperatorContext ------------------------------------------------------------------

NebulaSQLParser::ComparisonOperatorContext::ComparisonOperatorContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::EQ()
{
    return getToken(NebulaSQLParser::EQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQ()
{
    return getToken(NebulaSQLParser::NEQ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NEQJ()
{
    return getToken(NebulaSQLParser::NEQJ, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LT()
{
    return getToken(NebulaSQLParser::LT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::LTE()
{
    return getToken(NebulaSQLParser::LTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GT()
{
    return getToken(NebulaSQLParser::GT, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::GTE()
{
    return getToken(NebulaSQLParser::GTE, 0);
}

tree::TerminalNode* NebulaSQLParser::ComparisonOperatorContext::NSEQ()
{
    return getToken(NebulaSQLParser::NSEQ, 0);
}


size_t NebulaSQLParser::ComparisonOperatorContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleComparisonOperator;
}

void NebulaSQLParser::ComparisonOperatorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterComparisonOperator(this);
}

void NebulaSQLParser::ComparisonOperatorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitComparisonOperator(this);
}

NebulaSQLParser::ComparisonOperatorContext* NebulaSQLParser::comparisonOperator()
{
    ComparisonOperatorContext* _localctx = _tracker.createInstance<ComparisonOperatorContext>(_ctx, getState());
    enterRule(_localctx, 118, NebulaSQLParser::RuleComparisonOperator);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(710);
        _la = _input->LA(1);
        if (!(((((_la - 103) & ~0x3fULL) == 0) && ((1ULL << (_la - 103)) & 255) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HintContext ------------------------------------------------------------------

NebulaSQLParser::HintContext::HintContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::HintStatementContext*> NebulaSQLParser::HintContext::hintStatement()
{
    return getRuleContexts<NebulaSQLParser::HintStatementContext>();
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::HintContext::hintStatement(size_t i)
{
    return getRuleContext<NebulaSQLParser::HintStatementContext>(i);
}


size_t NebulaSQLParser::HintContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHint;
}

void NebulaSQLParser::HintContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHint(this);
}

void NebulaSQLParser::HintContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHint(this);
}

NebulaSQLParser::HintContext* NebulaSQLParser::hint()
{
    HintContext* _localctx = _tracker.createInstance<HintContext>(_ctx, getState());
    enterRule(_localctx, 120, NebulaSQLParser::RuleHint);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(712);
        match(NebulaSQLParser::T__5);
        setState(713);
        antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext = hintStatement();
        antlrcpp::downCast<HintContext*>(_localctx)->hintStatements.push_back(
            antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext);
        setState(720);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(715);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx))
                {
                    case 1: {
                        setState(714);
                        match(NebulaSQLParser::T__1);
                        break;
                    }

                    default:
                        break;
                }
                setState(717);
                antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext = hintStatement();
                antlrcpp::downCast<HintContext*>(_localctx)->hintStatements.push_back(
                    antlrcpp::downCast<HintContext*>(_localctx)->hintStatementContext);
            }
            setState(722);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx);
        }
        setState(723);
        match(NebulaSQLParser::T__6);
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- HintStatementContext ------------------------------------------------------------------

NebulaSQLParser::HintStatementContext::HintStatementContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::HintStatementContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

std::vector<NebulaSQLParser::PrimaryExpressionContext*> NebulaSQLParser::HintStatementContext::primaryExpression()
{
    return getRuleContexts<NebulaSQLParser::PrimaryExpressionContext>();
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::HintStatementContext::primaryExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(i);
}


size_t NebulaSQLParser::HintStatementContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleHintStatement;
}

void NebulaSQLParser::HintStatementContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterHintStatement(this);
}

void NebulaSQLParser::HintStatementContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitHintStatement(this);
}

NebulaSQLParser::HintStatementContext* NebulaSQLParser::hintStatement()
{
    HintStatementContext* _localctx = _tracker.createInstance<HintStatementContext>(_ctx, getState());
    enterRule(_localctx, 122, NebulaSQLParser::RuleHintStatement);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(738);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx))
        {
            case 1: {
                enterOuterAlt(_localctx, 1);
                setState(725);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->hintName = identifier();
                break;
            }

            case 2: {
                enterOuterAlt(_localctx, 2);
                setState(726);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->hintName = identifier();
                setState(727);
                match(NebulaSQLParser::T__2);
                setState(728);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext = primaryExpression(0);
                antlrcpp::downCast<HintStatementContext*>(_localctx)->parameters.push_back(
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext);
                setState(733);
                _errHandler->sync(this);
                _la = _input->LA(1);
                while (_la == NebulaSQLParser::T__1)
                {
                    setState(729);
                    match(NebulaSQLParser::T__1);
                    setState(730);
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext = primaryExpression(0);
                    antlrcpp::downCast<HintStatementContext*>(_localctx)->parameters.push_back(
                        antlrcpp::downCast<HintStatementContext*>(_localctx)->primaryExpressionContext);
                    setState(735);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                }
                setState(736);
                match(NebulaSQLParser::T__3);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::PrimaryExpressionContext::getRuleIndex() const
{
    return NebulaSQLParser::RulePrimaryExpression;
}

void NebulaSQLParser::PrimaryExpressionContext::copyFrom(PrimaryExpressionContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- DereferenceContext ------------------------------------------------------------------

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::DereferenceContext::primaryExpression()
{
    return getRuleContext<NebulaSQLParser::PrimaryExpressionContext>(0);
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::DereferenceContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::DereferenceContext::DereferenceContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DereferenceContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDereference(this);
}
void NebulaSQLParser::DereferenceContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDereference(this);
}
//----------------- ConstantDefaultContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext* NebulaSQLParser::ConstantDefaultContext::constant()
{
    return getRuleContext<NebulaSQLParser::ConstantContext>(0);
}

NebulaSQLParser::ConstantDefaultContext::ConstantDefaultContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ConstantDefaultContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterConstantDefault(this);
}
void NebulaSQLParser::ConstantDefaultContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitConstantDefault(this);
}
//----------------- ColumnReferenceContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::ColumnReferenceContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

NebulaSQLParser::ColumnReferenceContext::ColumnReferenceContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ColumnReferenceContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterColumnReference(this);
}
void NebulaSQLParser::ColumnReferenceContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitColumnReference(this);
}
//----------------- RowConstructorContext ------------------------------------------------------------------

std::vector<NebulaSQLParser::NamedExpressionContext*> NebulaSQLParser::RowConstructorContext::namedExpression()
{
    return getRuleContexts<NebulaSQLParser::NamedExpressionContext>();
}

NebulaSQLParser::NamedExpressionContext* NebulaSQLParser::RowConstructorContext::namedExpression(size_t i)
{
    return getRuleContext<NebulaSQLParser::NamedExpressionContext>(i);
}

NebulaSQLParser::RowConstructorContext::RowConstructorContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::RowConstructorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterRowConstructor(this);
}
void NebulaSQLParser::RowConstructorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitRowConstructor(this);
}
//----------------- ParenthesizedExpressionContext ------------------------------------------------------------------

NebulaSQLParser::ExpressionContext* NebulaSQLParser::ParenthesizedExpressionContext::expression()
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(0);
}

NebulaSQLParser::ParenthesizedExpressionContext::ParenthesizedExpressionContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ParenthesizedExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterParenthesizedExpression(this);
}
void NebulaSQLParser::ParenthesizedExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitParenthesizedExpression(this);
}
//----------------- StarContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::StarContext::ASTERISK()
{
    return getToken(NebulaSQLParser::ASTERISK, 0);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::StarContext::qualifiedName()
{
    return getRuleContext<NebulaSQLParser::QualifiedNameContext>(0);
}

NebulaSQLParser::StarContext::StarContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::StarContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStar(this);
}
void NebulaSQLParser::StarContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStar(this);
}
//----------------- FunctionCallContext ------------------------------------------------------------------

NebulaSQLParser::FunctionNameContext* NebulaSQLParser::FunctionCallContext::functionName()
{
    return getRuleContext<NebulaSQLParser::FunctionNameContext>(0);
}

std::vector<NebulaSQLParser::ExpressionContext*> NebulaSQLParser::FunctionCallContext::expression()
{
    return getRuleContexts<NebulaSQLParser::ExpressionContext>();
}

NebulaSQLParser::ExpressionContext* NebulaSQLParser::FunctionCallContext::expression(size_t i)
{
    return getRuleContext<NebulaSQLParser::ExpressionContext>(i);
}

NebulaSQLParser::FunctionCallContext::FunctionCallContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFunctionCall(this);
}
void NebulaSQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFunctionCall(this);
}
//----------------- SubqueryExpressionContext ------------------------------------------------------------------

NebulaSQLParser::QueryContext* NebulaSQLParser::SubqueryExpressionContext::query()
{
    return getRuleContext<NebulaSQLParser::QueryContext>(0);
}

NebulaSQLParser::SubqueryExpressionContext::SubqueryExpressionContext(PrimaryExpressionContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SubqueryExpressionContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSubqueryExpression(this);
}
void NebulaSQLParser::SubqueryExpressionContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSubqueryExpression(this);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression()
{
    return primaryExpression(0);
}

NebulaSQLParser::PrimaryExpressionContext* NebulaSQLParser::primaryExpression(int precedence)
{
    ParserRuleContext* parentContext = _ctx;
    size_t parentState = getState();
    NebulaSQLParser::PrimaryExpressionContext* _localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
    NebulaSQLParser::PrimaryExpressionContext* previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 124;
    enterRecursionRule(_localctx, 124, NebulaSQLParser::RulePrimaryExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            unrollRecursionContexts(parentContext);
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(780);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<StarContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;

                setState(741);
                match(NebulaSQLParser::ASTERISK);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<StarContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(742);
                qualifiedName();
                setState(743);
                match(NebulaSQLParser::T__4);
                setState(744);
                match(NebulaSQLParser::ASTERISK);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<SubqueryExpressionContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(746);
                match(NebulaSQLParser::T__2);
                setState(747);
                query();
                setState(748);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<RowConstructorContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(750);
                match(NebulaSQLParser::T__2);
                setState(751);
                namedExpression();
                setState(754);
                _errHandler->sync(this);
                _la = _input->LA(1);
                do
                {
                    setState(752);
                    match(NebulaSQLParser::T__1);
                    setState(753);
                    namedExpression();
                    setState(756);
                    _errHandler->sync(this);
                    _la = _input->LA(1);
                } while (_la == NebulaSQLParser::T__1);
                setState(758);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<FunctionCallContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(760);
                functionName();
                setState(761);
                match(NebulaSQLParser::T__2);
                setState(770);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx))
                {
                    case 1: {
                        setState(762);
                        antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext = expression();
                        antlrcpp::downCast<FunctionCallContext*>(_localctx)->argument.push_back(
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext);
                        setState(767);
                        _errHandler->sync(this);
                        _la = _input->LA(1);
                        while (_la == NebulaSQLParser::T__1)
                        {
                            setState(763);
                            match(NebulaSQLParser::T__1);
                            setState(764);
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext = expression();
                            antlrcpp::downCast<FunctionCallContext*>(_localctx)->argument.push_back(
                                antlrcpp::downCast<FunctionCallContext*>(_localctx)->expressionContext);
                            setState(769);
                            _errHandler->sync(this);
                            _la = _input->LA(1);
                        }
                        break;
                    }

                    default:
                        break;
                }
                setState(772);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 6: {
                _localctx = _tracker.createInstance<ParenthesizedExpressionContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(774);
                match(NebulaSQLParser::T__2);
                setState(775);
                expression();
                setState(776);
                match(NebulaSQLParser::T__3);
                break;
            }

            case 7: {
                _localctx = _tracker.createInstance<ConstantDefaultContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(778);
                constant();
                break;
            }

            case 8: {
                _localctx = _tracker.createInstance<ColumnReferenceContext>(_localctx);
                _ctx = _localctx;
                previousContext = _localctx;
                setState(779);
                identifier();
                break;
            }

            default:
                break;
        }
        _ctx->stop = _input->LT(-1);
        setState(787);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                if (!_parseListeners.empty())
                    triggerExitRuleEvent();
                previousContext = _localctx;
                auto newContext = _tracker.createInstance<DereferenceContext>(
                    _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState));
                _localctx = newContext;
                newContext->base = previousContext;
                pushNewRecursionContext(newContext, startState, RulePrimaryExpression);
                setState(782);

                if (!(precpred(_ctx, 7)))
                    throw FailedPredicateException(this, "precpred(_ctx, 7)");
                setState(783);
                match(NebulaSQLParser::T__4);
                setState(784);
                antlrcpp::downCast<DereferenceContext*>(_localctx)->fieldName = identifier();
            }
            setState(789);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
}

//----------------- QualifiedNameContext ------------------------------------------------------------------

NebulaSQLParser::QualifiedNameContext::QualifiedNameContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

std::vector<NebulaSQLParser::IdentifierContext*> NebulaSQLParser::QualifiedNameContext::identifier()
{
    return getRuleContexts<NebulaSQLParser::IdentifierContext>();
}

NebulaSQLParser::IdentifierContext* NebulaSQLParser::QualifiedNameContext::identifier(size_t i)
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(i);
}


size_t NebulaSQLParser::QualifiedNameContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleQualifiedName;
}

void NebulaSQLParser::QualifiedNameContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterQualifiedName(this);
}

void NebulaSQLParser::QualifiedNameContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitQualifiedName(this);
}

NebulaSQLParser::QualifiedNameContext* NebulaSQLParser::qualifiedName()
{
    QualifiedNameContext* _localctx = _tracker.createInstance<QualifiedNameContext>(_ctx, getState());
    enterRule(_localctx, 126, NebulaSQLParser::RuleQualifiedName);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        enterOuterAlt(_localctx, 1);
        setState(790);
        identifier();
        setState(795);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER)
        {
            if (alt == 1)
            {
                setState(791);
                match(NebulaSQLParser::T__4);
                setState(792);
                identifier();
            }
            setState(797);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext::NumberContext(ParserRuleContext* parent, size_t invokingState) : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::NumberContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNumber;
}

void NebulaSQLParser::NumberContext::copyFrom(NumberContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- DecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::DECIMAL_VALUE()
{
    return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::DecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DecimalLiteralContext::DecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDecimalLiteral(this);
}
void NebulaSQLParser::DecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDecimalLiteral(this);
}
//----------------- UnsignedSmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnsignedSmallIntLiteralContext::UNSIGNED_SMALLINT_LITERAL()
{
    return getToken(NebulaSQLParser::UNSIGNED_SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::UnsignedSmallIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::UnsignedSmallIntLiteralContext::UnsignedSmallIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnsignedSmallIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnsignedSmallIntLiteral(this);
}
void NebulaSQLParser::UnsignedSmallIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnsignedSmallIntLiteral(this);
}
//----------------- BigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::BIGINT_LITERAL()
{
    return getToken(NebulaSQLParser::BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigIntLiteralContext::BigIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BigIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBigIntLiteral(this);
}
void NebulaSQLParser::BigIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBigIntLiteral(this);
}
//----------------- TinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::TINYINT_LITERAL()
{
    return getToken(NebulaSQLParser::TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::TinyIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::TinyIntLiteralContext::TinyIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TinyIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTinyIntLiteral(this);
}
void NebulaSQLParser::TinyIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTinyIntLiteral(this);
}
//----------------- UnsignedBigIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnsignedBigIntLiteralContext::UNSIGNED_BIGINT_LITERAL()
{
    return getToken(NebulaSQLParser::UNSIGNED_BIGINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::UnsignedBigIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::UnsignedBigIntLiteralContext::UnsignedBigIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnsignedBigIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnsignedBigIntLiteral(this);
}
void NebulaSQLParser::UnsignedBigIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnsignedBigIntLiteral(this);
}
//----------------- ExponentLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::EXPONENT_VALUE()
{
    return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::ExponentLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::ExponentLiteralContext::ExponentLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::ExponentLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterExponentLiteral(this);
}
void NebulaSQLParser::ExponentLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitExponentLiteral(this);
}
//----------------- UnsignedIntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnsignedIntegerLiteralContext::UNSIGNED_INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::UNSIGNED_INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::UnsignedIntegerLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::UnsignedIntegerLiteralContext::UnsignedIntegerLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnsignedIntegerLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnsignedIntegerLiteral(this);
}
void NebulaSQLParser::UnsignedIntegerLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnsignedIntegerLiteral(this);
}
//----------------- SmallIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::SMALLINT_LITERAL()
{
    return getToken(NebulaSQLParser::SMALLINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::SmallIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::SmallIntLiteralContext::SmallIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::SmallIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterSmallIntLiteral(this);
}
void NebulaSQLParser::SmallIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitSmallIntLiteral(this);
}
//----------------- LegacyDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::EXPONENT_VALUE()
{
    return getToken(NebulaSQLParser::EXPONENT_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::DECIMAL_VALUE()
{
    return getToken(NebulaSQLParser::DECIMAL_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::LegacyDecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::LegacyDecimalLiteralContext::LegacyDecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::LegacyDecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterLegacyDecimalLiteral(this);
}
void NebulaSQLParser::LegacyDecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitLegacyDecimalLiteral(this);
}
//----------------- BigDecimalLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::BIGDECIMAL_LITERAL()
{
    return getToken(NebulaSQLParser::BIGDECIMAL_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::BigDecimalLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::BigDecimalLiteralContext::BigDecimalLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BigDecimalLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBigDecimalLiteral(this);
}
void NebulaSQLParser::BigDecimalLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBigDecimalLiteral(this);
}
//----------------- DoubleLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::DOUBLE_LITERAL()
{
    return getToken(NebulaSQLParser::DOUBLE_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::DoubleLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::DoubleLiteralContext::DoubleLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::DoubleLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterDoubleLiteral(this);
}
void NebulaSQLParser::DoubleLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitDoubleLiteral(this);
}
//----------------- IntegerLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::INTEGER_VALUE()
{
    return getToken(NebulaSQLParser::INTEGER_VALUE, 0);
}

tree::TerminalNode* NebulaSQLParser::IntegerLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::IntegerLiteralContext::IntegerLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::IntegerLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterIntegerLiteral(this);
}
void NebulaSQLParser::IntegerLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitIntegerLiteral(this);
}
//----------------- FloatLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::FLOAT_LITERAL()
{
    return getToken(NebulaSQLParser::FLOAT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::FloatLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::FloatLiteralContext::FloatLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::FloatLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterFloatLiteral(this);
}
void NebulaSQLParser::FloatLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitFloatLiteral(this);
}
//----------------- UnsignedTinyIntLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::UnsignedTinyIntLiteralContext::UNSIGNED_TINYINT_LITERAL()
{
    return getToken(NebulaSQLParser::UNSIGNED_TINYINT_LITERAL, 0);
}

tree::TerminalNode* NebulaSQLParser::UnsignedTinyIntLiteralContext::MINUS()
{
    return getToken(NebulaSQLParser::MINUS, 0);
}

NebulaSQLParser::UnsignedTinyIntLiteralContext::UnsignedTinyIntLiteralContext(NumberContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::UnsignedTinyIntLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterUnsignedTinyIntLiteral(this);
}
void NebulaSQLParser::UnsignedTinyIntLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitUnsignedTinyIntLiteral(this);
}
NebulaSQLParser::NumberContext* NebulaSQLParser::number()
{
    NumberContext* _localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
    enterRule(_localctx, 128, NebulaSQLParser::RuleNumber);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        setState(857);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::ExponentLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(798);

                if (!(!legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
                setState(800);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(799);
                    match(NebulaSQLParser::MINUS);
                }
                setState(802);
                match(NebulaSQLParser::EXPONENT_VALUE);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::DecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(803);

                if (!(!legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "!legacy_exponent_literal_as_decimal_enabled");
                setState(805);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(804);
                    match(NebulaSQLParser::MINUS);
                }
                setState(807);
                match(NebulaSQLParser::DECIMAL_VALUE);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::LegacyDecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(808);

                if (!(legacy_exponent_literal_as_decimal_enabled))
                    throw FailedPredicateException(this, "legacy_exponent_literal_as_decimal_enabled");
                setState(810);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(809);
                    match(NebulaSQLParser::MINUS);
                }
                setState(812);
                _la = _input->LA(1);
                if (!(_la == NebulaSQLParser::EXPONENT_VALUE

                      || _la == NebulaSQLParser::DECIMAL_VALUE))
                {
                    _errHandler->recoverInline(this);
                }
                else
                {
                    _errHandler->reportMatch(this);
                    consume();
                }
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::IntegerLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(814);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(813);
                    match(NebulaSQLParser::MINUS);
                }
                setState(816);
                match(NebulaSQLParser::INTEGER_VALUE);
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BigIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(818);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(817);
                    match(NebulaSQLParser::MINUS);
                }
                setState(820);
                match(NebulaSQLParser::BIGINT_LITERAL);
                break;
            }

            case 6: {
                _localctx = _tracker.createInstance<NebulaSQLParser::SmallIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 6);
                setState(822);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(821);
                    match(NebulaSQLParser::MINUS);
                }
                setState(824);
                match(NebulaSQLParser::SMALLINT_LITERAL);
                break;
            }

            case 7: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TinyIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 7);
                setState(826);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(825);
                    match(NebulaSQLParser::MINUS);
                }
                setState(828);
                match(NebulaSQLParser::TINYINT_LITERAL);
                break;
            }

            case 8: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnsignedIntegerLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 8);
                setState(830);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(829);
                    match(NebulaSQLParser::MINUS);
                }
                setState(832);
                match(NebulaSQLParser::UNSIGNED_INTEGER_VALUE);
                break;
            }

            case 9: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnsignedBigIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 9);
                setState(834);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(833);
                    match(NebulaSQLParser::MINUS);
                }
                setState(836);
                match(NebulaSQLParser::UNSIGNED_BIGINT_LITERAL);
                break;
            }

            case 10: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnsignedSmallIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 10);
                setState(838);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(837);
                    match(NebulaSQLParser::MINUS);
                }
                setState(840);
                match(NebulaSQLParser::UNSIGNED_SMALLINT_LITERAL);
                break;
            }

            case 11: {
                _localctx = _tracker.createInstance<NebulaSQLParser::UnsignedTinyIntLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 11);
                setState(842);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(841);
                    match(NebulaSQLParser::MINUS);
                }
                setState(844);
                match(NebulaSQLParser::UNSIGNED_TINYINT_LITERAL);
                break;
            }

            case 12: {
                _localctx = _tracker.createInstance<NebulaSQLParser::DoubleLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 12);
                setState(846);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(845);
                    match(NebulaSQLParser::MINUS);
                }
                setState(848);
                match(NebulaSQLParser::DOUBLE_LITERAL);
                break;
            }

            case 13: {
                _localctx = _tracker.createInstance<NebulaSQLParser::FloatLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 13);
                setState(850);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(849);
                    match(NebulaSQLParser::MINUS);
                }
                setState(852);
                match(NebulaSQLParser::FLOAT_LITERAL);
                break;
            }

            case 14: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BigDecimalLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 14);
                setState(854);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == NebulaSQLParser::MINUS)
                {
                    setState(853);
                    match(NebulaSQLParser::MINUS);
                }
                setState(856);
                match(NebulaSQLParser::BIGDECIMAL_LITERAL);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NebulaSQLParser::ConstantContext::ConstantContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}


size_t NebulaSQLParser::ConstantContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleConstant;
}

void NebulaSQLParser::ConstantContext::copyFrom(ConstantContext* ctx)
{
    ParserRuleContext::copyFrom(ctx);
}

//----------------- NullLiteralContext ------------------------------------------------------------------

tree::TerminalNode* NebulaSQLParser::NullLiteralContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

NebulaSQLParser::NullLiteralContext::NullLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNullLiteral(this);
}
void NebulaSQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNullLiteral(this);
}
//----------------- StringLiteralContext ------------------------------------------------------------------

std::vector<tree::TerminalNode*> NebulaSQLParser::StringLiteralContext::STRING()
{
    return getTokens(NebulaSQLParser::STRING);
}

tree::TerminalNode* NebulaSQLParser::StringLiteralContext::STRING(size_t i)
{
    return getToken(NebulaSQLParser::STRING, i);
}

NebulaSQLParser::StringLiteralContext::StringLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::StringLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStringLiteral(this);
}
void NebulaSQLParser::StringLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStringLiteral(this);
}
//----------------- TypeConstructorContext ------------------------------------------------------------------

NebulaSQLParser::IdentifierContext* NebulaSQLParser::TypeConstructorContext::identifier()
{
    return getRuleContext<NebulaSQLParser::IdentifierContext>(0);
}

tree::TerminalNode* NebulaSQLParser::TypeConstructorContext::STRING()
{
    return getToken(NebulaSQLParser::STRING, 0);
}

NebulaSQLParser::TypeConstructorContext::TypeConstructorContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::TypeConstructorContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterTypeConstructor(this);
}
void NebulaSQLParser::TypeConstructorContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitTypeConstructor(this);
}
//----------------- NumericLiteralContext ------------------------------------------------------------------

NebulaSQLParser::NumberContext* NebulaSQLParser::NumericLiteralContext::number()
{
    return getRuleContext<NebulaSQLParser::NumberContext>(0);
}

NebulaSQLParser::NumericLiteralContext::NumericLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::NumericLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNumericLiteral(this);
}
void NebulaSQLParser::NumericLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNumericLiteral(this);
}
//----------------- BooleanLiteralContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::BooleanLiteralContext::booleanValue()
{
    return getRuleContext<NebulaSQLParser::BooleanValueContext>(0);
}

NebulaSQLParser::BooleanLiteralContext::BooleanLiteralContext(ConstantContext* ctx)
{
    copyFrom(ctx);
}

void NebulaSQLParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBooleanLiteral(this);
}
void NebulaSQLParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBooleanLiteral(this);
}
NebulaSQLParser::ConstantContext* NebulaSQLParser::constant()
{
    ConstantContext* _localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
    enterRule(_localctx, 130, NebulaSQLParser::RuleConstant);

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        size_t alt;
        setState(870);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx))
        {
            case 1: {
                _localctx = _tracker.createInstance<NebulaSQLParser::NullLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 1);
                setState(859);
                match(NebulaSQLParser::NULLTOKEN);
                break;
            }

            case 2: {
                _localctx = _tracker.createInstance<NebulaSQLParser::TypeConstructorContext>(_localctx);
                enterOuterAlt(_localctx, 2);
                setState(860);
                identifier();
                setState(861);
                match(NebulaSQLParser::STRING);
                break;
            }

            case 3: {
                _localctx = _tracker.createInstance<NebulaSQLParser::NumericLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 3);
                setState(863);
                number();
                break;
            }

            case 4: {
                _localctx = _tracker.createInstance<NebulaSQLParser::BooleanLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 4);
                setState(864);
                booleanValue();
                break;
            }

            case 5: {
                _localctx = _tracker.createInstance<NebulaSQLParser::StringLiteralContext>(_localctx);
                enterOuterAlt(_localctx, 5);
                setState(866);
                _errHandler->sync(this);
                alt = 1;
                do
                {
                    switch (alt)
                    {
                        case 1: {
                            setState(865);
                            match(NebulaSQLParser::STRING);
                            break;
                        }

                        default:
                            throw NoViableAltException(this);
                    }
                    setState(868);
                    _errHandler->sync(this);
                    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
                } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
                break;
            }

            default:
                break;
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

NebulaSQLParser::BooleanValueContext::BooleanValueContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::BooleanValueContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}


size_t NebulaSQLParser::BooleanValueContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleBooleanValue;
}

void NebulaSQLParser::BooleanValueContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterBooleanValue(this);
}

void NebulaSQLParser::BooleanValueContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitBooleanValue(this);
}

NebulaSQLParser::BooleanValueContext* NebulaSQLParser::booleanValue()
{
    BooleanValueContext* _localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
    enterRule(_localctx, 132, NebulaSQLParser::RuleBooleanValue);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(872);
        _la = _input->LA(1);
        if (!(_la == NebulaSQLParser::FALSE

              || _la == NebulaSQLParser::TRUE))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- StrictNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::StrictNonReservedContext::StrictNonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::FULL()
{
    return getToken(NebulaSQLParser::FULL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::INNER()
{
    return getToken(NebulaSQLParser::INNER, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::JOIN()
{
    return getToken(NebulaSQLParser::JOIN, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::LEFT()
{
    return getToken(NebulaSQLParser::LEFT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::NATURAL()
{
    return getToken(NebulaSQLParser::NATURAL, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::ON()
{
    return getToken(NebulaSQLParser::ON, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::RIGHT()
{
    return getToken(NebulaSQLParser::RIGHT, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::UNION()
{
    return getToken(NebulaSQLParser::UNION, 0);
}

tree::TerminalNode* NebulaSQLParser::StrictNonReservedContext::USING()
{
    return getToken(NebulaSQLParser::USING, 0);
}


size_t NebulaSQLParser::StrictNonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleStrictNonReserved;
}

void NebulaSQLParser::StrictNonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterStrictNonReserved(this);
}

void NebulaSQLParser::StrictNonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitStrictNonReserved(this);
}

NebulaSQLParser::StrictNonReservedContext* NebulaSQLParser::strictNonReserved()
{
    StrictNonReservedContext* _localctx = _tracker.createInstance<StrictNonReservedContext>(_ctx, getState());
    enterRule(_localctx, 134, NebulaSQLParser::RuleStrictNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(874);
        _la = _input->LA(1);
        if (!(((((_la - 32) & ~0x3fULL) == 0) && ((1ULL << (_la - 32)) & 2474039710785) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- AnsiNonReservedContext ------------------------------------------------------------------

NebulaSQLParser::AnsiNonReservedContext::AnsiNonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::AT()
{
    return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DELETE()
{
    return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::DROP()
{
    return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::INSERT()
{
    return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::MERGE()
{
    return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::QUERY()
{
    return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::TYPE()
{
    return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::AnsiNonReservedContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}


size_t NebulaSQLParser::AnsiNonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleAnsiNonReserved;
}

void NebulaSQLParser::AnsiNonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterAnsiNonReserved(this);
}

void NebulaSQLParser::AnsiNonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitAnsiNonReserved(this);
}

NebulaSQLParser::AnsiNonReservedContext* NebulaSQLParser::ansiNonReserved()
{
    AnsiNonReservedContext* _localctx = _tracker.createInstance<AnsiNonReservedContext>(_ctx, getState());
    enterRule(_localctx, 136, NebulaSQLParser::RuleAnsiNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(876);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -5615592343523696640) != 0)
              || ((((_la - 68) & ~0x3fULL) == 0) && ((1ULL << (_la - 68)) & 579) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

//----------------- NonReservedContext ------------------------------------------------------------------

NebulaSQLParser::NonReservedContext::NonReservedContext(ParserRuleContext* parent, size_t invokingState)
    : ParserRuleContext(parent, invokingState)
{
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ASC()
{
    return getToken(NebulaSQLParser::ASC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AT()
{
    return getToken(NebulaSQLParser::AT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BETWEEN()
{
    return getToken(NebulaSQLParser::BETWEEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::CUBE()
{
    return getToken(NebulaSQLParser::CUBE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::BY()
{
    return getToken(NebulaSQLParser::BY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DELETE()
{
    return getToken(NebulaSQLParser::DELETE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DESC()
{
    return getToken(NebulaSQLParser::DESC, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DIV()
{
    return getToken(NebulaSQLParser::DIV, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DROP()
{
    return getToken(NebulaSQLParser::DROP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::EXISTS()
{
    return getToken(NebulaSQLParser::EXISTS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FIRST()
{
    return getToken(NebulaSQLParser::FIRST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUPING()
{
    return getToken(NebulaSQLParser::GROUPING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INSERT()
{
    return getToken(NebulaSQLParser::INSERT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LAST()
{
    return getToken(NebulaSQLParser::LAST, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIKE()
{
    return getToken(NebulaSQLParser::LIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::LIMIT()
{
    return getToken(NebulaSQLParser::LIMIT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::MERGE()
{
    return getToken(NebulaSQLParser::MERGE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLS()
{
    return getToken(NebulaSQLParser::NULLS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::QUERY()
{
    return getToken(NebulaSQLParser::QUERY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::RLIKE()
{
    return getToken(NebulaSQLParser::RLIKE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ROLLUP()
{
    return getToken(NebulaSQLParser::ROLLUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SETS()
{
    return getToken(NebulaSQLParser::SETS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TRUE()
{
    return getToken(NebulaSQLParser::TRUE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TYPE()
{
    return getToken(NebulaSQLParser::TYPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::VALUES()
{
    return getToken(NebulaSQLParser::VALUES, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WINDOW()
{
    return getToken(NebulaSQLParser::WINDOW, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ALL()
{
    return getToken(NebulaSQLParser::ALL, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AND()
{
    return getToken(NebulaSQLParser::AND, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ANY()
{
    return getToken(NebulaSQLParser::ANY, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::AS()
{
    return getToken(NebulaSQLParser::AS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::DISTINCT()
{
    return getToken(NebulaSQLParser::DISTINCT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ESCAPE()
{
    return getToken(NebulaSQLParser::ESCAPE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FALSE()
{
    return getToken(NebulaSQLParser::FALSE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::FROM()
{
    return getToken(NebulaSQLParser::FROM, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::GROUP()
{
    return getToken(NebulaSQLParser::GROUP, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::HAVING()
{
    return getToken(NebulaSQLParser::HAVING, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IN()
{
    return getToken(NebulaSQLParser::IN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::INTO()
{
    return getToken(NebulaSQLParser::INTO, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::IS()
{
    return getToken(NebulaSQLParser::IS, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NOT()
{
    return getToken(NebulaSQLParser::NOT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::NULLTOKEN()
{
    return getToken(NebulaSQLParser::NULLTOKEN, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::OR()
{
    return getToken(NebulaSQLParser::OR, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::ORDER()
{
    return getToken(NebulaSQLParser::ORDER, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SELECT()
{
    return getToken(NebulaSQLParser::SELECT, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::SOME()
{
    return getToken(NebulaSQLParser::SOME, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::TABLE()
{
    return getToken(NebulaSQLParser::TABLE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WHERE()
{
    return getToken(NebulaSQLParser::WHERE, 0);
}

tree::TerminalNode* NebulaSQLParser::NonReservedContext::WITH()
{
    return getToken(NebulaSQLParser::WITH, 0);
}


size_t NebulaSQLParser::NonReservedContext::getRuleIndex() const
{
    return NebulaSQLParser::RuleNonReserved;
}

void NebulaSQLParser::NonReservedContext::enterRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->enterNonReserved(this);
}

void NebulaSQLParser::NonReservedContext::exitRule(tree::ParseTreeListener* listener)
{
    auto parserListener = dynamic_cast<NebulaSQLListener*>(listener);
    if (parserListener != nullptr)
        parserListener->exitNonReserved(this);
}

NebulaSQLParser::NonReservedContext* NebulaSQLParser::nonReserved()
{
    NonReservedContext* _localctx = _tracker.createInstance<NonReservedContext>(_ctx, getState());
    enterRule(_localctx, 138, NebulaSQLParser::RuleNonReserved);
    size_t _la = 0;

#if __cplusplus > 201703L
    auto onExit = finally(
        [=, this]
        {
#else
    auto onExit = finally(
        [=]
        {
#endif
            exitRule();
        });
    try
    {
        enterOuterAlt(_localctx, 1);
        setState(878);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -892438752910246400) != 0)
              || ((((_la - 64) & ~0x3fULL) == 0) && ((1ULL << (_la - 64)) & 29749) != 0)))
        {
            _errHandler->recoverInline(this);
        }
        else
        {
            _errHandler->reportMatch(this);
            consume();
        }
    }
    catch (RecognitionException& e)
    {
        _errHandler->reportError(this, e);
        _localctx->exception = std::current_exception();
        _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
}

bool NebulaSQLParser::sempred(RuleContext* context, size_t ruleIndex, size_t predicateIndex)
{
    switch (ruleIndex)
    {
        case 4:
            return queryTermSempred(antlrcpp::downCast<QueryTermContext*>(context), predicateIndex);
        case 24:
            return identifierSempred(antlrcpp::downCast<IdentifierContext*>(context), predicateIndex);
        case 25:
            return strictIdentifierSempred(antlrcpp::downCast<StrictIdentifierContext*>(context), predicateIndex);
        case 33:
            return booleanExpressionSempred(antlrcpp::downCast<BooleanExpressionContext*>(context), predicateIndex);
        case 58:
            return valueExpressionSempred(antlrcpp::downCast<ValueExpressionContext*>(context), predicateIndex);
        case 62:
            return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext*>(context), predicateIndex);
        case 64:
            return numberSempred(antlrcpp::downCast<NumberContext*>(context), predicateIndex);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::queryTermSempred(QueryTermContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 0:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::identifierSempred(IdentifierContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 1:
            return !SQL_standard_keyword_behavior;

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::strictIdentifierSempred(StrictIdentifierContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 2:
            return SQL_standard_keyword_behavior;
        case 3:
            return !SQL_standard_keyword_behavior;

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::booleanExpressionSempred(BooleanExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 4:
            return precpred(_ctx, 2);
        case 5:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::valueExpressionSempred(ValueExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 6:
            return precpred(_ctx, 6);
        case 7:
            return precpred(_ctx, 5);
        case 8:
            return precpred(_ctx, 4);
        case 9:
            return precpred(_ctx, 3);
        case 10:
            return precpred(_ctx, 2);
        case 11:
            return precpred(_ctx, 1);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::primaryExpressionSempred(PrimaryExpressionContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 12:
            return precpred(_ctx, 7);

        default:
            break;
    }
    return true;
}

bool NebulaSQLParser::numberSempred(NumberContext* _localctx, size_t predicateIndex)
{
    switch (predicateIndex)
    {
        case 13:
            return !legacy_exponent_literal_as_decimal_enabled;
        case 14:
            return !legacy_exponent_literal_as_decimal_enabled;
        case 15:
            return legacy_exponent_literal_as_decimal_enabled;

        default:
            break;
    }
    return true;
}

void NebulaSQLParser::initialize()
{
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    nebulasqlParserInitialize();
#else
    ::antlr4::internal::call_once(nebulasqlParserOnceFlag, nebulasqlParserInitialize);
#endif
}
