#!/usr/bin/expect -f

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# Usage: ./test_query.exp /path/to/nebuli-embedded

if {[llength $argv] < 1} {
    puts "Usage: $argv0 <nebuli-executable>"
    exit 1
}

set nebuli [lindex $argv 0]
set timeout 30

# Convert to absolute path before changing directory
set nebuli [exec realpath $nebuli]

# Source helper procedures
source [file dirname [info script]]/helpers.exp

# Ensure output is not buffered
log_user 0
exp_internal 0

# Create temp directory and spawn nebuli
set temp_dir [exec mktemp -d]
cd $temp_dir

spawn $nebuli -f JSON

wait_for_prompt

send "CREATE LOGICAL SOURCE endless(ts UINT64);\r"
expect_json_equal {[{"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_name":"ENDLESS"}]} "CREATE LOGICAL SOURCE"

send "CREATE PHYSICAL SOURCE FOR endless TYPE Generator SET('ALL' as \`SOURCE\`.STOP_GENERATOR_WHEN_SEQUENCE_FINISHES, 'CSV' as PARSER.\`TYPE\`, 10000000 AS \`SOURCE\`.MAX_RUNTIME_MS, 1 AS \`SOURCE\`.SEED, 'SEQUENCE UINT64 0 10000000 1' AS \`SOURCE\`.GENERATOR_SCHEMA);\r"
set expected {[{"parser_config":{"field_delimiter":",","tuple_delimiter":"\n","type":"CSV"},"physical_source_id":1,"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_config":[{"flush_interval_ms":10},{"generator_rate_config":"emit_rate 1000"},{"generator_rate_type":"FIXED"},{"generator_schema":"SEQUENCE UINT64 0 10000000 1"},{"max_inflight_buffers":0},{"max_runtime_ms":10000000},{"seed":1},{"stop_generator_when_sequence_finishes":"ALL"}],"source_name":"ENDLESS","source_type":"Generator"}]}
expect_json_equal $expected "CREATE Physical Source"

send "CREATE SINK someSink(ENDLESS.TS UINT64) TYPE File SET('out.csv' as \`SINK\`.FILE_PATH, 'CSV' as \`SINK\`.INPUT_FORMAT);\r"
expect_json_equal {[{"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"sink_config":[{"add_timestamp":false},{"append":false},{"file_path":"out.csv"},{"input_format":"CSV"}],"sink_name":"SOMESINK","sink_type":"File"}]} "CREATE SINK"

send "SHOW QUERIES;\r"
expect_json_equal {[]} "SHOW QUERIES (empty)"

send "SELECT TS FROM ENDLESS INTO SOMESINK;\r"
set json [expect_json "Timeout waiting for SELECT response"]
# Extract the query ID using jq
set query_id [exec echo $json | jq -r ".\[0\].local_query_id"]

send "SHOW QUERIES;\r"
set json [expect_json "Timeout waiting for SHOW QUERIES response"]
# Check that we have exactly one query
set count [exec echo $json | jq ". | length"]
if {$count != "1"} {
    fail "SHOW QUERIES - expected 1 query, got $count"
}
# Check that local_query_id matches
set returned_id [exec echo $json | jq -r ".\[0\].local_query_id"]
if {$returned_id ne $query_id} {
    fail "SHOW QUERIES - query_id mismatch" $query_id $returned_id
}
# Check that query_status matches one of the expected states
set status_match [exec echo $json | jq ".\[0\].query_status | test(\"^Running|Registered|Started\$\")"]
if {$status_match ne "true"} {
    fail "SHOW QUERIES - unexpected query status"
}

send "SHOW QUERIES WHERE id = $query_id;\r"
set json [expect_json "Timeout waiting for SHOW QUERIES WHERE response"]
# Verify we get exactly the query we asked for
set returned_id [exec echo $json | jq -r ".\[0\].local_query_id"]
if {$returned_id ne $query_id} {
    fail "SHOW QUERIES WHERE - query_id mismatch" $query_id $returned_id
}

send "DROP QUERY $query_id;\r"
set json [expect_json "Timeout waiting for DROP QUERY response"]
# Check that the response contains the query ID
set returned_id [exec echo $json | jq -r ".\[0\].local_query_id"]
if {$returned_id ne $query_id} {
    fail "DROP QUERY - query_id mismatch" $query_id $returned_id
}

send "SHOW QUERIES;\r"
set json [expect_json "Timeout waiting for final SHOW QUERIES response"]
# Should be empty or have the query in Stopped state
# Depending on implementation, stopped queries might still show

# Exit cleanly
send "exit\r"
expect eof

exec rm -rf $temp_dir

exit 0
