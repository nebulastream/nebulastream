#!/usr/bin/expect -f

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set timeout 30
set script_dir [file dirname [info script]]

# Source helper procedures
source $script_dir/../helpers.exp

# Ensure output is not buffered
log_user 0
exp_internal 0

# Setup distributed Docker Compose environment with 8-node topology
setup "1-node.yaml"

# Spawn nes-repl inside the docker container
spawn docker compose exec -it nes-repl nes-repl -s worker-node:8080 -d -f JSON

wait_for_prompt

send_sql {CREATE LOGICAL SOURCE endless(ts UINT64);}
expect_json_equal {[{"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_name":"ENDLESS"}]} "CREATE LOGICAL SOURCE"

send_sql {CREATE PHYSICAL SOURCE FOR endless TYPE Generator SET('ALL' as `SOURCE`.STOP_GENERATOR_WHEN_SEQUENCE_FINISHES, 'CSV' as PARSER.`TYPE`, 'emit_rate 10' AS `SOURCE`.GENERATOR_RATE_CONFIG, 10000000 AS `SOURCE`.MAX_RUNTIME_MS, 1 AS `SOURCE`.SEED, 'SEQUENCE UINT64 0 10000000 1' AS `SOURCE`.GENERATOR_SCHEMA);}
set expected {[{"parser_config":{"field_delimiter":",","tuple_delimiter":"\n","type":"CSV"},"physical_source_id":1,"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_config":[{"flush_interval_ms":10},{"generator_rate_config":"emit_rate 10"},{"generator_rate_type":"FIXED"},{"generator_schema":"SEQUENCE UINT64 0 10000000 1"},{"max_inflight_buffers":0},{"max_runtime_ms":10000000},{"seed":1},{"stop_generator_when_sequence_finishes":"ALL"}],"source_name":"ENDLESS","source_type":"Generator"}]}
expect_json_equal $expected "CREATE Physical Source"

send_sql {CREATE SINK someSink(ENDLESS.TS UINT64) TYPE File SET('out.csv' as `SINK`.FILE_PATH, 'CSV' as `SINK`.INPUT_FORMAT);}
expect_json_equal {[{"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"sink_config":[{"add_timestamp":false},{"append":false},{"file_path":"out.csv"},{"input_format":"CSV"}],"sink_name":"SOMESINK","sink_type":"File"}]} "CREATE SINK"

send_sql {SHOW QUERIES;}
expect_json_equal {[]} "SHOW QUERIES (empty)"

send_sql {SELECT TS FROM ENDLESS INTO SOMESINK;}
set json [expect_json "Timeout waiting for SELECT response"]
# Extract the query ID using jq
set query_id [jq $json {.[0].query_id}]

send_sql {SHOW QUERIES;}
set json [expect_json "Timeout waiting for SHOW QUERIES response"]
# Check that we have exactly 2 queries (one global, and one local)
set count [jq $json {. | length}]
if {$count != "1"} {
    fail "SHOW QUERIES - expected 1 query (one local), got $count"
}
# Check that query_id matches
set returned_id [jq $json {.[0].query_id}]
if {$returned_id ne $query_id} {
    fail "SHOW QUERIES - query_id mismatch" $query_id $returned_id
}
# Check that query_status matches one of the expected states
assert_jq_test $json {.[0].query_status | test("^Running|Registered|Started$")} "SHOW QUERIES - unexpected query status"

puts "$query_id"
send_sql "SHOW QUERIES WHERE ID = $query_id;"
set json [expect_json "Timeout waiting for SHOW QUERIES WHERE response"]
# Verify we get exactly the query we asked for
set returned_id [jq $json {.[0].query_id}]
if {$returned_id ne $query_id} {
    fail "SHOW QUERIES WHERE - query_id mismatch" $query_id $returned_id
}

send_sql "DROP QUERY WHERE ID = $query_id;"
set json [expect_json "Timeout waiting for DROP QUERY response"]
# Check that the response contains the query ID
set returned_id [jq $json {.[0].query_id}]
if {$returned_id ne $query_id} {
    fail "DROP QUERY - query_id mismatch" $query_id $returned_id
}

send_sql {SHOW QUERIES;}
expect_json_equal {[]} "SHOW QUERIES (empty after drop)"

# Exit cleanly
send "exit\r"
expect eof

exit 0
