#!/usr/bin/expect -f

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set timeout 30
set script_dir [file dirname [info script]]

# Source helper procedures
source $script_dir/../helpers.exp

# Ensure output is not buffered
log_user 0
exp_internal 0

# Setup distributed Docker Compose environment with 8-node topology
setup "8-node.yaml"

# Spawn nes-repl inside the docker container
spawn docker compose exec -t nes-repl nes-repl -d -f JSON

wait_for_prompt

send_sql {
    CREATE WORKER "sink-node:9090" AT "sink-node:8080";
}
expect_json_equal {[{"worker":"sink-node:8080"}]} "CREATE WORKER"

send_sql {
    CREATE WORKER "source-node-1:9090" AT "source-node-1:8080"
    SET("sink-node:8080" AS `DOWNSTREAM`);
}
expect_json_equal {[{"worker":"source-node-1:8080"}]} "CREATE WORKER"

send_sql {CREATE LOGICAL SOURCE endless(ts UINT64);}
expect_json_equal {[{"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_name":"ENDLESS"}]} "CREATE LOGICAL SOURCE"

send_sql {
    CREATE PHYSICAL SOURCE FOR endless
    TYPE Generator
    SET(
        'ALL' as `SOURCE`.STOP_GENERATOR_WHEN_SEQUENCE_FINISHES,
        'CSV' as PARSER.`TYPE`,
        'emit_rate 10' AS `SOURCE`.GENERATOR_RATE_CONFIG,
        10000000 AS `SOURCE`.MAX_RUNTIME_MS,
        "source-node-1:8080" AS `SOURCE`.`HOST`,
        1 AS `SOURCE`.SEED,
        'SEQUENCE UINT64 0 10000000 1' AS `SOURCE`.GENERATOR_SCHEMA
    );
}

set expected {[{"host":"source-node-1:8080","parser_config":{"field_delimiter":",","tuple_delimiter":"\n","type":"CSV"},"physical_source_id":1,"schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"source_config":[{"flush_interval_ms":10},{"generator_rate_config":"emit_rate 10"},{"generator_rate_type":"FIXED"},{"generator_schema":"SEQUENCE UINT64 0 10000000 1"},{"max_inflight_buffers":0},{"max_runtime_ms":10000000},{"seed":1},{"stop_generator_when_sequence_finishes":"ALL"}],"source_name":"ENDLESS","source_type":"Generator"}]}
expect_json_equal $expected "CREATE Physical Source"

send_sql {
    CREATE SINK someSink(ENDLESS.TS UINT64)
    TYPE File
    SET(
        'out.csv' as `SINK`.FILE_PATH,
        'CSV' as `SINK`.INPUT_FORMAT,
        "sink-node:8080" AS `SINK`.`HOST`
    );
}
expect_json_equal {[{"host":"sink-node:8080","schema":[[{"name":"ENDLESS$TS","type":"UINT64"}]],"sink_config":[{"add_timestamp":false},{"append":false},{"file_path":"out.csv"},{"input_format":"CSV"}],"sink_name":"SOMESINK","sink_type":"File"}]} "CREATE SINK"

send_sql {
    SELECT TS
    FROM ENDLESS
    INTO SOMESINK;
}

set json [expect_json "Timeout waiting for Query response"]
# Extract the query ID using jq
set query_id1 [jq $json {.[0].query_id}]

send_sql {
    SELECT ID, VALUE, TIMESTAMP
    FROM Generator(
        'ALL' as `SOURCE`.STOP_GENERATOR_WHEN_SEQUENCE_FINISHES,
        'CSV' as PARSER.`TYPE`,
        'emit_rate 10' AS `SOURCE`.GENERATOR_RATE_CONFIG,
        10000000 AS `SOURCE`.MAX_RUNTIME_MS,
        "source-node-1:8080" AS `SOURCE`.`HOST`,
        1 AS `SOURCE`.SEED,
        'SEQUENCE UINT64 0 10000000 1' AS `SOURCE`.GENERATOR_SCHEMA,
        SCHEMA(id UINT64, value UINT64, timestamp UINT64) AS `SOURCE`.`SCHEMA`)
    INTO Print("source-node-1:8080" AS `SINK`.`HOST`, "CSV" AS `SINK`.`INPUT_FORMAT`);
}
set json [expect_json "submitting second inline source/sink query"]

puts $query_id1
send_sql {
    SHOW QUERIES;
}

set json [expect_json "Getting final list of queries"]
set count [jq $json {. | length}]
if {$count != "5"} {
    fail "SHOW QUERIES - expected 5 queries (two global, and 3 local), got $count"
}

# Exit cleanly
send "exit\r"
expect eof

exit 0
